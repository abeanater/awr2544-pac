#[doc = "Register `CSI2_VC_CTRL_2` reader"]
pub type R = crate::R<Csi2VcCtrl2Spec>;
#[doc = "Register `CSI2_VC_CTRL_2` writer"]
pub type W = crate::W<Csi2VcCtrl2Spec>;
#[doc = "0:0\\]
Enables the virtual channel.\n\nValue on reset: 0"]
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub enum VcEn {
    #[doc = "0: Disabled. The virtual channel shall be disabled for any register change in the CSI2_VC_... registers the corresponding virtual channel id (except for setting the bit-fields/registers: CSI2_VC_CTRL.BTA_EN, CSI2_VC_TE.TE_SIZE, CSI2_VC_TE.TE_START, CSI2_VC_LONG_,,, CSI2_VC_SHORT_..., CSI2_VC_IRQ...)."]
    Disable = 0,
    #[doc = "1: Enabled. No change is allowed to the virtual channel registers expect resetting the VC_EN."]
    Enable = 1,
}
impl From<VcEn> for bool {
    #[inline(always)]
    fn from(variant: VcEn) -> Self {
        variant as u8 != 0
    }
}
#[doc = "Field `VC_EN` reader - 0:0\\]
Enables the virtual channel."]
pub type VcEnR = crate::BitReader<VcEn>;
impl VcEnR {
    #[doc = "Get enumerated values variant"]
    #[inline(always)]
    pub const fn variant(&self) -> VcEn {
        match self.bits {
            false => VcEn::Disable,
            true => VcEn::Enable,
        }
    }
    #[doc = "Disabled. The virtual channel shall be disabled for any register change in the CSI2_VC_... registers the corresponding virtual channel id (except for setting the bit-fields/registers: CSI2_VC_CTRL.BTA_EN, CSI2_VC_TE.TE_SIZE, CSI2_VC_TE.TE_START, CSI2_VC_LONG_,,, CSI2_VC_SHORT_..., CSI2_VC_IRQ...)."]
    #[inline(always)]
    pub fn is_disable(&self) -> bool {
        *self == VcEn::Disable
    }
    #[doc = "Enabled. No change is allowed to the virtual channel registers expect resetting the VC_EN."]
    #[inline(always)]
    pub fn is_enable(&self) -> bool {
        *self == VcEn::Enable
    }
}
#[doc = "Field `VC_EN` writer - 0:0\\]
Enables the virtual channel."]
pub type VcEnW<'a, REG> = crate::BitWriter<'a, REG, VcEn>;
impl<'a, REG> VcEnW<'a, REG>
where
    REG: crate::Writable + crate::RegisterSpec,
{
    #[doc = "Disabled. The virtual channel shall be disabled for any register change in the CSI2_VC_... registers the corresponding virtual channel id (except for setting the bit-fields/registers: CSI2_VC_CTRL.BTA_EN, CSI2_VC_TE.TE_SIZE, CSI2_VC_TE.TE_START, CSI2_VC_LONG_,,, CSI2_VC_SHORT_..., CSI2_VC_IRQ...)."]
    #[inline(always)]
    pub fn disable(self) -> &'a mut crate::W<REG> {
        self.variant(VcEn::Disable)
    }
    #[doc = "Enabled. No change is allowed to the virtual channel registers expect resetting the VC_EN."]
    #[inline(always)]
    pub fn enable(self) -> &'a mut crate::W<REG> {
        self.variant(VcEn::Enable)
    }
}
#[doc = "1:1\\]
Selection of the source between OCP and the Video port(s) (used by the HW only if MODE=COMMAND MODE (0x0) otherwise it is ignored). The number of available video ports is defined in CSI2_GNQ.NB_VIDEO_PORTS.\n\nValue on reset: 0"]
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub enum Source {
    #[doc = "0: All the data are provided by the slave port. Any transfer on the video port is ignored for this virtual channel."]
    OcpSlavePort = 0,
    #[doc = "1: If MODE=VIDEO_MODE. the data received on the video port 1 or video port 2, selected using VP_SOURCE (pixels and enabled synchronization events using CSI2_CTRL1.VP_HSYNC_START, CSI2_CTRL1.VP_HSYNC_END, CSI2_CTRL1.VP_VSYNC_START, CSI2_CTRL1.VP_VSYNC_END for video port 1 and CSI2_CTRL2.VP_HSYNC_START, CSI2_CTRL2.VP_HSYNC_END, CSI2_CTRL2.VP_VSYNC_START, CSI2_CTRL2.VP_VSYNC_END for video port 2) are sent on the virtual channel (only one virtual channel can be associated with the video port, it is the SW responsibility to ensure that no more than one virtual channel is enabled with the video port as the main source for data). If MODE=COMMAND_MODE, the VP.STALL signal is used by the protocol engine to indicate when new data are required. The synchronization signals are not generated by the display controller. Regardless of the MODE, no data can be provided on the OCP slave port."]
    VideoPort = 1,
}
impl From<Source> for bool {
    #[inline(always)]
    fn from(variant: Source) -> Self {
        variant as u8 != 0
    }
}
#[doc = "Field `SOURCE` reader - 1:1\\]
Selection of the source between OCP and the Video port(s) (used by the HW only if MODE=COMMAND MODE (0x0) otherwise it is ignored). The number of available video ports is defined in CSI2_GNQ.NB_VIDEO_PORTS."]
pub type SourceR = crate::BitReader<Source>;
impl SourceR {
    #[doc = "Get enumerated values variant"]
    #[inline(always)]
    pub const fn variant(&self) -> Source {
        match self.bits {
            false => Source::OcpSlavePort,
            true => Source::VideoPort,
        }
    }
    #[doc = "All the data are provided by the slave port. Any transfer on the video port is ignored for this virtual channel."]
    #[inline(always)]
    pub fn is_ocp_slave_port(&self) -> bool {
        *self == Source::OcpSlavePort
    }
    #[doc = "If MODE=VIDEO_MODE. the data received on the video port 1 or video port 2, selected using VP_SOURCE (pixels and enabled synchronization events using CSI2_CTRL1.VP_HSYNC_START, CSI2_CTRL1.VP_HSYNC_END, CSI2_CTRL1.VP_VSYNC_START, CSI2_CTRL1.VP_VSYNC_END for video port 1 and CSI2_CTRL2.VP_HSYNC_START, CSI2_CTRL2.VP_HSYNC_END, CSI2_CTRL2.VP_VSYNC_START, CSI2_CTRL2.VP_VSYNC_END for video port 2) are sent on the virtual channel (only one virtual channel can be associated with the video port, it is the SW responsibility to ensure that no more than one virtual channel is enabled with the video port as the main source for data). If MODE=COMMAND_MODE, the VP.STALL signal is used by the protocol engine to indicate when new data are required. The synchronization signals are not generated by the display controller. Regardless of the MODE, no data can be provided on the OCP slave port."]
    #[inline(always)]
    pub fn is_video_port(&self) -> bool {
        *self == Source::VideoPort
    }
}
#[doc = "Field `SOURCE` writer - 1:1\\]
Selection of the source between OCP and the Video port(s) (used by the HW only if MODE=COMMAND MODE (0x0) otherwise it is ignored). The number of available video ports is defined in CSI2_GNQ.NB_VIDEO_PORTS."]
pub type SourceW<'a, REG> = crate::BitWriter<'a, REG, Source>;
impl<'a, REG> SourceW<'a, REG>
where
    REG: crate::Writable + crate::RegisterSpec,
{
    #[doc = "All the data are provided by the slave port. Any transfer on the video port is ignored for this virtual channel."]
    #[inline(always)]
    pub fn ocp_slave_port(self) -> &'a mut crate::W<REG> {
        self.variant(Source::OcpSlavePort)
    }
    #[doc = "If MODE=VIDEO_MODE. the data received on the video port 1 or video port 2, selected using VP_SOURCE (pixels and enabled synchronization events using CSI2_CTRL1.VP_HSYNC_START, CSI2_CTRL1.VP_HSYNC_END, CSI2_CTRL1.VP_VSYNC_START, CSI2_CTRL1.VP_VSYNC_END for video port 1 and CSI2_CTRL2.VP_HSYNC_START, CSI2_CTRL2.VP_HSYNC_END, CSI2_CTRL2.VP_VSYNC_START, CSI2_CTRL2.VP_VSYNC_END for video port 2) are sent on the virtual channel (only one virtual channel can be associated with the video port, it is the SW responsibility to ensure that no more than one virtual channel is enabled with the video port as the main source for data). If MODE=COMMAND_MODE, the VP.STALL signal is used by the protocol engine to indicate when new data are required. The synchronization signals are not generated by the display controller. Regardless of the MODE, no data can be provided on the OCP slave port."]
    #[inline(always)]
    pub fn video_port(self) -> &'a mut crate::W<REG> {
        self.variant(Source::VideoPort)
    }
}
#[doc = "2:2\\]
Enables the automatic bus turn-around after completion of each short packet transmission.\n\nValue on reset: 0"]
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub enum BtaShortEn {
    #[doc = "0: Disabled"]
    Disable = 0,
    #[doc = "1: Enabled"]
    Enable = 1,
}
impl From<BtaShortEn> for bool {
    #[inline(always)]
    fn from(variant: BtaShortEn) -> Self {
        variant as u8 != 0
    }
}
#[doc = "Field `BTA_SHORT_EN` reader - 2:2\\]
Enables the automatic bus turn-around after completion of each short packet transmission."]
pub type BtaShortEnR = crate::BitReader<BtaShortEn>;
impl BtaShortEnR {
    #[doc = "Get enumerated values variant"]
    #[inline(always)]
    pub const fn variant(&self) -> BtaShortEn {
        match self.bits {
            false => BtaShortEn::Disable,
            true => BtaShortEn::Enable,
        }
    }
    #[doc = "Disabled"]
    #[inline(always)]
    pub fn is_disable(&self) -> bool {
        *self == BtaShortEn::Disable
    }
    #[doc = "Enabled"]
    #[inline(always)]
    pub fn is_enable(&self) -> bool {
        *self == BtaShortEn::Enable
    }
}
#[doc = "Field `BTA_SHORT_EN` writer - 2:2\\]
Enables the automatic bus turn-around after completion of each short packet transmission."]
pub type BtaShortEnW<'a, REG> = crate::BitWriter<'a, REG, BtaShortEn>;
impl<'a, REG> BtaShortEnW<'a, REG>
where
    REG: crate::Writable + crate::RegisterSpec,
{
    #[doc = "Disabled"]
    #[inline(always)]
    pub fn disable(self) -> &'a mut crate::W<REG> {
        self.variant(BtaShortEn::Disable)
    }
    #[doc = "Enabled"]
    #[inline(always)]
    pub fn enable(self) -> &'a mut crate::W<REG> {
        self.variant(BtaShortEn::Enable)
    }
}
#[doc = "3:3\\]
Enables the automatic bus turn-around after completion of each long packet transmission.\n\nValue on reset: 0"]
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub enum BtaLongEn {
    #[doc = "0: Disabled"]
    Disable = 0,
    #[doc = "1: Enabled"]
    Enable = 1,
}
impl From<BtaLongEn> for bool {
    #[inline(always)]
    fn from(variant: BtaLongEn) -> Self {
        variant as u8 != 0
    }
}
#[doc = "Field `BTA_LONG_EN` reader - 3:3\\]
Enables the automatic bus turn-around after completion of each long packet transmission."]
pub type BtaLongEnR = crate::BitReader<BtaLongEn>;
impl BtaLongEnR {
    #[doc = "Get enumerated values variant"]
    #[inline(always)]
    pub const fn variant(&self) -> BtaLongEn {
        match self.bits {
            false => BtaLongEn::Disable,
            true => BtaLongEn::Enable,
        }
    }
    #[doc = "Disabled"]
    #[inline(always)]
    pub fn is_disable(&self) -> bool {
        *self == BtaLongEn::Disable
    }
    #[doc = "Enabled"]
    #[inline(always)]
    pub fn is_enable(&self) -> bool {
        *self == BtaLongEn::Enable
    }
}
#[doc = "Field `BTA_LONG_EN` writer - 3:3\\]
Enables the automatic bus turn-around after completion of each long packet transmission."]
pub type BtaLongEnW<'a, REG> = crate::BitWriter<'a, REG, BtaLongEn>;
impl<'a, REG> BtaLongEnW<'a, REG>
where
    REG: crate::Writable + crate::RegisterSpec,
{
    #[doc = "Disabled"]
    #[inline(always)]
    pub fn disable(self) -> &'a mut crate::W<REG> {
        self.variant(BtaLongEn::Disable)
    }
    #[doc = "Enabled"]
    #[inline(always)]
    pub fn enable(self) -> &'a mut crate::W<REG> {
        self.variant(BtaLongEn::Enable)
    }
}
#[doc = "4:4\\]
Selection of the mode\n\nValue on reset: 0"]
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub enum Mode {
    #[doc = "0: Command mode."]
    CommandMode = 0,
    #[doc = "1: Video mode. The bit-fields MODE_SPEED and SOURCE are not used by HW. The bit-field VP_SOURCE is used to select between video port 1 and video port 2 when two video ports are present."]
    VideoMode = 1,
}
impl From<Mode> for bool {
    #[inline(always)]
    fn from(variant: Mode) -> Self {
        variant as u8 != 0
    }
}
#[doc = "Field `MODE` reader - 4:4\\]
Selection of the mode"]
pub type ModeR = crate::BitReader<Mode>;
impl ModeR {
    #[doc = "Get enumerated values variant"]
    #[inline(always)]
    pub const fn variant(&self) -> Mode {
        match self.bits {
            false => Mode::CommandMode,
            true => Mode::VideoMode,
        }
    }
    #[doc = "Command mode."]
    #[inline(always)]
    pub fn is_command_mode(&self) -> bool {
        *self == Mode::CommandMode
    }
    #[doc = "Video mode. The bit-fields MODE_SPEED and SOURCE are not used by HW. The bit-field VP_SOURCE is used to select between video port 1 and video port 2 when two video ports are present."]
    #[inline(always)]
    pub fn is_video_mode(&self) -> bool {
        *self == Mode::VideoMode
    }
}
#[doc = "Field `MODE` writer - 4:4\\]
Selection of the mode"]
pub type ModeW<'a, REG> = crate::BitWriter<'a, REG, Mode>;
impl<'a, REG> ModeW<'a, REG>
where
    REG: crate::Writable + crate::RegisterSpec,
{
    #[doc = "Command mode."]
    #[inline(always)]
    pub fn command_mode(self) -> &'a mut crate::W<REG> {
        self.variant(Mode::CommandMode)
    }
    #[doc = "Video mode. The bit-fields MODE_SPEED and SOURCE are not used by HW. The bit-field VP_SOURCE is used to select between video port 1 and video port 2 when two video ports are present."]
    #[inline(always)]
    pub fn video_mode(self) -> &'a mut crate::W<REG> {
        self.variant(Mode::VideoMode)
    }
}
#[doc = "5:5\\]
FIFO status\n\nValue on reset: 0"]
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub enum TxFifoNotEmpty {
    #[doc = "0: The TX FIFO is empty (the FIFO does not contain any data for the virtual channel)"]
    Empty = 0,
    #[doc = "1: The TX FIFO is not empty (the FIFO contains at least one byte for the virtual channel)"]
    NotEmpty = 1,
}
impl From<TxFifoNotEmpty> for bool {
    #[inline(always)]
    fn from(variant: TxFifoNotEmpty) -> Self {
        variant as u8 != 0
    }
}
#[doc = "Field `TX_FIFO_NOT_EMPTY` reader - 5:5\\]
FIFO status"]
pub type TxFifoNotEmptyR = crate::BitReader<TxFifoNotEmpty>;
impl TxFifoNotEmptyR {
    #[doc = "Get enumerated values variant"]
    #[inline(always)]
    pub const fn variant(&self) -> TxFifoNotEmpty {
        match self.bits {
            false => TxFifoNotEmpty::Empty,
            true => TxFifoNotEmpty::NotEmpty,
        }
    }
    #[doc = "The TX FIFO is empty (the FIFO does not contain any data for the virtual channel)"]
    #[inline(always)]
    pub fn is_empty(&self) -> bool {
        *self == TxFifoNotEmpty::Empty
    }
    #[doc = "The TX FIFO is not empty (the FIFO contains at least one byte for the virtual channel)"]
    #[inline(always)]
    pub fn is_not_empty(&self) -> bool {
        *self == TxFifoNotEmpty::NotEmpty
    }
}
#[doc = "Field `TX_FIFO_NOT_EMPTY` writer - 5:5\\]
FIFO status"]
pub type TxFifoNotEmptyW<'a, REG> = crate::BitWriter<'a, REG, TxFifoNotEmpty>;
impl<'a, REG> TxFifoNotEmptyW<'a, REG>
where
    REG: crate::Writable + crate::RegisterSpec,
{
    #[doc = "The TX FIFO is empty (the FIFO does not contain any data for the virtual channel)"]
    #[inline(always)]
    pub fn empty(self) -> &'a mut crate::W<REG> {
        self.variant(TxFifoNotEmpty::Empty)
    }
    #[doc = "The TX FIFO is not empty (the FIFO contains at least one byte for the virtual channel)"]
    #[inline(always)]
    pub fn not_empty(self) -> &'a mut crate::W<REG> {
        self.variant(TxFifoNotEmpty::NotEmpty)
    }
}
#[doc = "6:6\\]
Send the bus turn around to the peripheral. It can be used when the automatic mode is enabled (BTA_SHORT_EN=1 or/and BTA_LONG_EN=1). In that case only one BTA is sent to the peripheral. The manual mode is used to allow the user to define for which packets, the turn around is required for example getting acknowledge from the peripheral.\n\nValue on reset: 0"]
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub enum BtaEn {
    #[doc = "0: READS: BTA generation is completed. It is reset by HW when it is completed. WRITES: Cancellation of the BTA generation (not guarantee since it could already on going, shall not be used)."]
    Disable = 0,
    #[doc = "1: READS: BTA generation has been requested by user (it could be on going but not completed). WRITES: Request for BTA generation."]
    Enable = 1,
}
impl From<BtaEn> for bool {
    #[inline(always)]
    fn from(variant: BtaEn) -> Self {
        variant as u8 != 0
    }
}
#[doc = "Field `BTA_EN` reader - 6:6\\]
Send the bus turn around to the peripheral. It can be used when the automatic mode is enabled (BTA_SHORT_EN=1 or/and BTA_LONG_EN=1). In that case only one BTA is sent to the peripheral. The manual mode is used to allow the user to define for which packets, the turn around is required for example getting acknowledge from the peripheral."]
pub type BtaEnR = crate::BitReader<BtaEn>;
impl BtaEnR {
    #[doc = "Get enumerated values variant"]
    #[inline(always)]
    pub const fn variant(&self) -> BtaEn {
        match self.bits {
            false => BtaEn::Disable,
            true => BtaEn::Enable,
        }
    }
    #[doc = "READS: BTA generation is completed. It is reset by HW when it is completed. WRITES: Cancellation of the BTA generation (not guarantee since it could already on going, shall not be used)."]
    #[inline(always)]
    pub fn is_disable(&self) -> bool {
        *self == BtaEn::Disable
    }
    #[doc = "READS: BTA generation has been requested by user (it could be on going but not completed). WRITES: Request for BTA generation."]
    #[inline(always)]
    pub fn is_enable(&self) -> bool {
        *self == BtaEn::Enable
    }
}
#[doc = "Field `BTA_EN` writer - 6:6\\]
Send the bus turn around to the peripheral. It can be used when the automatic mode is enabled (BTA_SHORT_EN=1 or/and BTA_LONG_EN=1). In that case only one BTA is sent to the peripheral. The manual mode is used to allow the user to define for which packets, the turn around is required for example getting acknowledge from the peripheral."]
pub type BtaEnW<'a, REG> = crate::BitWriter<'a, REG, BtaEn>;
impl<'a, REG> BtaEnW<'a, REG>
where
    REG: crate::Writable + crate::RegisterSpec,
{
    #[doc = "READS: BTA generation is completed. It is reset by HW when it is completed. WRITES: Cancellation of the BTA generation (not guarantee since it could already on going, shall not be used)."]
    #[inline(always)]
    pub fn disable(self) -> &'a mut crate::W<REG> {
        self.variant(BtaEn::Disable)
    }
    #[doc = "READS: BTA generation has been requested by user (it could be on going but not completed). WRITES: Request for BTA generation."]
    #[inline(always)]
    pub fn enable(self) -> &'a mut crate::W<REG> {
        self.variant(BtaEn::Enable)
    }
}
#[doc = "7:7\\]
Enables the checksum generation for the transmit payload (long packet only).\n\nValue on reset: 0"]
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub enum CsTxEn {
    #[doc = "0: Disabled. The value 0x00 is used."]
    Disable = 0,
    #[doc = "1: Enabled. The Check-sum value is calculated by HW."]
    Enable = 1,
}
impl From<CsTxEn> for bool {
    #[inline(always)]
    fn from(variant: CsTxEn) -> Self {
        variant as u8 != 0
    }
}
#[doc = "Field `CS_TX_EN` reader - 7:7\\]
Enables the checksum generation for the transmit payload (long packet only)."]
pub type CsTxEnR = crate::BitReader<CsTxEn>;
impl CsTxEnR {
    #[doc = "Get enumerated values variant"]
    #[inline(always)]
    pub const fn variant(&self) -> CsTxEn {
        match self.bits {
            false => CsTxEn::Disable,
            true => CsTxEn::Enable,
        }
    }
    #[doc = "Disabled. The value 0x00 is used."]
    #[inline(always)]
    pub fn is_disable(&self) -> bool {
        *self == CsTxEn::Disable
    }
    #[doc = "Enabled. The Check-sum value is calculated by HW."]
    #[inline(always)]
    pub fn is_enable(&self) -> bool {
        *self == CsTxEn::Enable
    }
}
#[doc = "Field `CS_TX_EN` writer - 7:7\\]
Enables the checksum generation for the transmit payload (long packet only)."]
pub type CsTxEnW<'a, REG> = crate::BitWriter<'a, REG, CsTxEn>;
impl<'a, REG> CsTxEnW<'a, REG>
where
    REG: crate::Writable + crate::RegisterSpec,
{
    #[doc = "Disabled. The value 0x00 is used."]
    #[inline(always)]
    pub fn disable(self) -> &'a mut crate::W<REG> {
        self.variant(CsTxEn::Disable)
    }
    #[doc = "Enabled. The Check-sum value is calculated by HW."]
    #[inline(always)]
    pub fn enable(self) -> &'a mut crate::W<REG> {
        self.variant(CsTxEn::Enable)
    }
}
#[doc = "8:8\\]
Enables the Error Correction Code generation for the transmit header (short and long packets).\n\nValue on reset: 0"]
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub enum EccTxEn {
    #[doc = "0: Disabled"]
    Disable = 0,
    #[doc = "1: Enabled"]
    Enable = 1,
}
impl From<EccTxEn> for bool {
    #[inline(always)]
    fn from(variant: EccTxEn) -> Self {
        variant as u8 != 0
    }
}
#[doc = "Field `ECC_TX_EN` reader - 8:8\\]
Enables the Error Correction Code generation for the transmit header (short and long packets)."]
pub type EccTxEnR = crate::BitReader<EccTxEn>;
impl EccTxEnR {
    #[doc = "Get enumerated values variant"]
    #[inline(always)]
    pub const fn variant(&self) -> EccTxEn {
        match self.bits {
            false => EccTxEn::Disable,
            true => EccTxEn::Enable,
        }
    }
    #[doc = "Disabled"]
    #[inline(always)]
    pub fn is_disable(&self) -> bool {
        *self == EccTxEn::Disable
    }
    #[doc = "Enabled"]
    #[inline(always)]
    pub fn is_enable(&self) -> bool {
        *self == EccTxEn::Enable
    }
}
#[doc = "Field `ECC_TX_EN` writer - 8:8\\]
Enables the Error Correction Code generation for the transmit header (short and long packets)."]
pub type EccTxEnW<'a, REG> = crate::BitWriter<'a, REG, EccTxEn>;
impl<'a, REG> EccTxEnW<'a, REG>
where
    REG: crate::Writable + crate::RegisterSpec,
{
    #[doc = "Disabled"]
    #[inline(always)]
    pub fn disable(self) -> &'a mut crate::W<REG> {
        self.variant(EccTxEn::Disable)
    }
    #[doc = "Enabled"]
    #[inline(always)]
    pub fn enable(self) -> &'a mut crate::W<REG> {
        self.variant(EccTxEn::Enable)
    }
}
#[doc = "9:9\\]
Selection of the mode. The information is used by HW only if MODE=COMMAND_MODE otherwise it is ignored.\n\nValue on reset: 0"]
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub enum ModeSpeed {
    #[doc = "0: Low power mode (CMOS) is used to send short and long packets to the peripheral."]
    Lp = 0,
    #[doc = "1: High Speed mode (SLVS) is used to send short and long packets to the peripheral."]
    Hs = 1,
}
impl From<ModeSpeed> for bool {
    #[inline(always)]
    fn from(variant: ModeSpeed) -> Self {
        variant as u8 != 0
    }
}
#[doc = "Field `MODE_SPEED` reader - 9:9\\]
Selection of the mode. The information is used by HW only if MODE=COMMAND_MODE otherwise it is ignored."]
pub type ModeSpeedR = crate::BitReader<ModeSpeed>;
impl ModeSpeedR {
    #[doc = "Get enumerated values variant"]
    #[inline(always)]
    pub const fn variant(&self) -> ModeSpeed {
        match self.bits {
            false => ModeSpeed::Lp,
            true => ModeSpeed::Hs,
        }
    }
    #[doc = "Low power mode (CMOS) is used to send short and long packets to the peripheral."]
    #[inline(always)]
    pub fn is_lp(&self) -> bool {
        *self == ModeSpeed::Lp
    }
    #[doc = "High Speed mode (SLVS) is used to send short and long packets to the peripheral."]
    #[inline(always)]
    pub fn is_hs(&self) -> bool {
        *self == ModeSpeed::Hs
    }
}
#[doc = "Field `MODE_SPEED` writer - 9:9\\]
Selection of the mode. The information is used by HW only if MODE=COMMAND_MODE otherwise it is ignored."]
pub type ModeSpeedW<'a, REG> = crate::BitWriter<'a, REG, ModeSpeed>;
impl<'a, REG> ModeSpeedW<'a, REG>
where
    REG: crate::Writable + crate::RegisterSpec,
{
    #[doc = "Low power mode (CMOS) is used to send short and long packets to the peripheral."]
    #[inline(always)]
    pub fn lp(self) -> &'a mut crate::W<REG> {
        self.variant(ModeSpeed::Lp)
    }
    #[doc = "High Speed mode (SLVS) is used to send short and long packets to the peripheral."]
    #[inline(always)]
    pub fn hs(self) -> &'a mut crate::W<REG> {
        self.variant(ModeSpeed::Hs)
    }
}
#[doc = "11:10\\]
Defines the size of the OCP data bus\n\nValue on reset: 0"]
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
#[repr(u8)]
pub enum OcpDataBusWidth {
    #[doc = "0: 16-bits data width (LSB of the 32-bit OCP port data bus)"]
    F16 = 0,
    #[doc = "1: 24-bits data width (LSB of the 32-bit OCP port data bus)"]
    F24 = 1,
    #[doc = "2: 2x16-bits data width (first pixel on the LSB of the 32-bit OCP port data bus and second pixel on the MSB of the 32-bit OCP port data bus for the same OCP access)"]
    F1616 = 2,
    #[doc = "3: 32-bits data width"]
    F32 = 3,
}
impl From<OcpDataBusWidth> for u8 {
    #[inline(always)]
    fn from(variant: OcpDataBusWidth) -> Self {
        variant as _
    }
}
impl crate::FieldSpec for OcpDataBusWidth {
    type Ux = u8;
}
impl crate::IsEnum for OcpDataBusWidth {}
#[doc = "Field `OCP_DATA_BUS_WIDTH` reader - 11:10\\]
Defines the size of the OCP data bus"]
pub type OcpDataBusWidthR = crate::FieldReader<OcpDataBusWidth>;
impl OcpDataBusWidthR {
    #[doc = "Get enumerated values variant"]
    #[inline(always)]
    pub const fn variant(&self) -> OcpDataBusWidth {
        match self.bits {
            0 => OcpDataBusWidth::F16,
            1 => OcpDataBusWidth::F24,
            2 => OcpDataBusWidth::F1616,
            3 => OcpDataBusWidth::F32,
            _ => unreachable!(),
        }
    }
    #[doc = "16-bits data width (LSB of the 32-bit OCP port data bus)"]
    #[inline(always)]
    pub fn is_f16(&self) -> bool {
        *self == OcpDataBusWidth::F16
    }
    #[doc = "24-bits data width (LSB of the 32-bit OCP port data bus)"]
    #[inline(always)]
    pub fn is_f24(&self) -> bool {
        *self == OcpDataBusWidth::F24
    }
    #[doc = "2x16-bits data width (first pixel on the LSB of the 32-bit OCP port data bus and second pixel on the MSB of the 32-bit OCP port data bus for the same OCP access)"]
    #[inline(always)]
    pub fn is_f1616(&self) -> bool {
        *self == OcpDataBusWidth::F1616
    }
    #[doc = "32-bits data width"]
    #[inline(always)]
    pub fn is_f32(&self) -> bool {
        *self == OcpDataBusWidth::F32
    }
}
#[doc = "Field `OCP_DATA_BUS_WIDTH` writer - 11:10\\]
Defines the size of the OCP data bus"]
pub type OcpDataBusWidthW<'a, REG> = crate::FieldWriter<'a, REG, 2, OcpDataBusWidth, crate::Safe>;
impl<'a, REG> OcpDataBusWidthW<'a, REG>
where
    REG: crate::Writable + crate::RegisterSpec,
    REG::Ux: From<u8>,
{
    #[doc = "16-bits data width (LSB of the 32-bit OCP port data bus)"]
    #[inline(always)]
    pub fn f16(self) -> &'a mut crate::W<REG> {
        self.variant(OcpDataBusWidth::F16)
    }
    #[doc = "24-bits data width (LSB of the 32-bit OCP port data bus)"]
    #[inline(always)]
    pub fn f24(self) -> &'a mut crate::W<REG> {
        self.variant(OcpDataBusWidth::F24)
    }
    #[doc = "2x16-bits data width (first pixel on the LSB of the 32-bit OCP port data bus and second pixel on the MSB of the 32-bit OCP port data bus for the same OCP access)"]
    #[inline(always)]
    pub fn f1616(self) -> &'a mut crate::W<REG> {
        self.variant(OcpDataBusWidth::F1616)
    }
    #[doc = "32-bits data width"]
    #[inline(always)]
    pub fn f32(self) -> &'a mut crate::W<REG> {
        self.variant(OcpDataBusWidth::F32)
    }
}
#[doc = "12:12\\]
Byte order for RBG565\n\nValue on reset: 0"]
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub enum Rgb565Order {
    #[doc = "0: Byte order as documented in the MIPI DBI-2 spec"]
    Rgb565Dbi2 = 0,
    #[doc = "1: Byte order as for video mode"]
    Rgb565Video = 1,
}
impl From<Rgb565Order> for bool {
    #[inline(always)]
    fn from(variant: Rgb565Order) -> Self {
        variant as u8 != 0
    }
}
#[doc = "Field `RGB565_ORDER` reader - 12:12\\]
Byte order for RBG565"]
pub type Rgb565OrderR = crate::BitReader<Rgb565Order>;
impl Rgb565OrderR {
    #[doc = "Get enumerated values variant"]
    #[inline(always)]
    pub const fn variant(&self) -> Rgb565Order {
        match self.bits {
            false => Rgb565Order::Rgb565Dbi2,
            true => Rgb565Order::Rgb565Video,
        }
    }
    #[doc = "Byte order as documented in the MIPI DBI-2 spec"]
    #[inline(always)]
    pub fn is_rgb565_dbi2(&self) -> bool {
        *self == Rgb565Order::Rgb565Dbi2
    }
    #[doc = "Byte order as for video mode"]
    #[inline(always)]
    pub fn is_rgb565_video(&self) -> bool {
        *self == Rgb565Order::Rgb565Video
    }
}
#[doc = "Field `RGB565_ORDER` writer - 12:12\\]
Byte order for RBG565"]
pub type Rgb565OrderW<'a, REG> = crate::BitWriter<'a, REG, Rgb565Order>;
impl<'a, REG> Rgb565OrderW<'a, REG>
where
    REG: crate::Writable + crate::RegisterSpec,
{
    #[doc = "Byte order as documented in the MIPI DBI-2 spec"]
    #[inline(always)]
    pub fn rgb565_dbi2(self) -> &'a mut crate::W<REG> {
        self.variant(Rgb565Order::Rgb565Dbi2)
    }
    #[doc = "Byte order as for video mode"]
    #[inline(always)]
    pub fn rgb565_video(self) -> &'a mut crate::W<REG> {
        self.variant(Rgb565Order::Rgb565Video)
    }
}
#[doc = "13:13\\]
Selection between video port 1 and video port 2. If CSI2_GNQ.NB_VIDEO_PORTS=0, the bit-field is ignored since only video port 1 is present.\n\nValue on reset: 0"]
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub enum VpSource {
    #[doc = "0: The video port 1 is selected."]
    VideoPort1 = 0,
    #[doc = "1: The video port 2 is selected."]
    VideoPort2 = 1,
}
impl From<VpSource> for bool {
    #[inline(always)]
    fn from(variant: VpSource) -> Self {
        variant as u8 != 0
    }
}
#[doc = "Field `VP_SOURCE` reader - 13:13\\]
Selection between video port 1 and video port 2. If CSI2_GNQ.NB_VIDEO_PORTS=0, the bit-field is ignored since only video port 1 is present."]
pub type VpSourceR = crate::BitReader<VpSource>;
impl VpSourceR {
    #[doc = "Get enumerated values variant"]
    #[inline(always)]
    pub const fn variant(&self) -> VpSource {
        match self.bits {
            false => VpSource::VideoPort1,
            true => VpSource::VideoPort2,
        }
    }
    #[doc = "The video port 1 is selected."]
    #[inline(always)]
    pub fn is_video_port_1(&self) -> bool {
        *self == VpSource::VideoPort1
    }
    #[doc = "The video port 2 is selected."]
    #[inline(always)]
    pub fn is_video_port_2(&self) -> bool {
        *self == VpSource::VideoPort2
    }
}
#[doc = "Field `VP_SOURCE` writer - 13:13\\]
Selection between video port 1 and video port 2. If CSI2_GNQ.NB_VIDEO_PORTS=0, the bit-field is ignored since only video port 1 is present."]
pub type VpSourceW<'a, REG> = crate::BitWriter<'a, REG, VpSource>;
impl<'a, REG> VpSourceW<'a, REG>
where
    REG: crate::Writable + crate::RegisterSpec,
{
    #[doc = "The video port 1 is selected."]
    #[inline(always)]
    pub fn video_port_1(self) -> &'a mut crate::W<REG> {
        self.variant(VpSource::VideoPort1)
    }
    #[doc = "The video port 2 is selected."]
    #[inline(always)]
    pub fn video_port_2(self) -> &'a mut crate::W<REG> {
        self.variant(VpSource::VideoPort2)
    }
}
#[doc = "14:14\\]
Ping-pong buffer busy status.\n\nValue on reset: 0"]
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub enum PpBusy {
    #[doc = "0: Software is permitted to write a new header for VP command mode traffic."]
    PpFree = 0,
    #[doc = "1: Software is NOT permitted to write a new header for VP command mode traffic."]
    PpBusy = 1,
}
impl From<PpBusy> for bool {
    #[inline(always)]
    fn from(variant: PpBusy) -> Self {
        variant as u8 != 0
    }
}
#[doc = "Field `PP_BUSY` reader - 14:14\\]
Ping-pong buffer busy status."]
pub type PpBusyR = crate::BitReader<PpBusy>;
impl PpBusyR {
    #[doc = "Get enumerated values variant"]
    #[inline(always)]
    pub const fn variant(&self) -> PpBusy {
        match self.bits {
            false => PpBusy::PpFree,
            true => PpBusy::PpBusy,
        }
    }
    #[doc = "Software is permitted to write a new header for VP command mode traffic."]
    #[inline(always)]
    pub fn is_pp_free(&self) -> bool {
        *self == PpBusy::PpFree
    }
    #[doc = "Software is NOT permitted to write a new header for VP command mode traffic."]
    #[inline(always)]
    pub fn is_pp_busy(&self) -> bool {
        *self == PpBusy::PpBusy
    }
}
#[doc = "Field `PP_BUSY` writer - 14:14\\]
Ping-pong buffer busy status."]
pub type PpBusyW<'a, REG> = crate::BitWriter<'a, REG, PpBusy>;
impl<'a, REG> PpBusyW<'a, REG>
where
    REG: crate::Writable + crate::RegisterSpec,
{
    #[doc = "Software is permitted to write a new header for VP command mode traffic."]
    #[inline(always)]
    pub fn pp_free(self) -> &'a mut crate::W<REG> {
        self.variant(PpBusy::PpFree)
    }
    #[doc = "Software is NOT permitted to write a new header for VP command mode traffic."]
    #[inline(always)]
    pub fn pp_busy(self) -> &'a mut crate::W<REG> {
        self.variant(PpBusy::PpBusy)
    }
}
#[doc = "15:15\\]
Indicates if previously scheduled activities (packets, BTA) are still being processed. Forced to 1 if VC is enabled. Software should check this bit is 0 before changing channel configuration.\n\nValue on reset: 0"]
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub enum VcBusy {
    #[doc = "0: No pending operations for this VC"]
    Completed = 0,
    #[doc = "1: Pending operations for this VC"]
    Busy = 1,
}
impl From<VcBusy> for bool {
    #[inline(always)]
    fn from(variant: VcBusy) -> Self {
        variant as u8 != 0
    }
}
#[doc = "Field `VC_BUSY` reader - 15:15\\]
Indicates if previously scheduled activities (packets, BTA) are still being processed. Forced to 1 if VC is enabled. Software should check this bit is 0 before changing channel configuration."]
pub type VcBusyR = crate::BitReader<VcBusy>;
impl VcBusyR {
    #[doc = "Get enumerated values variant"]
    #[inline(always)]
    pub const fn variant(&self) -> VcBusy {
        match self.bits {
            false => VcBusy::Completed,
            true => VcBusy::Busy,
        }
    }
    #[doc = "No pending operations for this VC"]
    #[inline(always)]
    pub fn is_completed(&self) -> bool {
        *self == VcBusy::Completed
    }
    #[doc = "Pending operations for this VC"]
    #[inline(always)]
    pub fn is_busy(&self) -> bool {
        *self == VcBusy::Busy
    }
}
#[doc = "Field `VC_BUSY` writer - 15:15\\]
Indicates if previously scheduled activities (packets, BTA) are still being processed. Forced to 1 if VC is enabled. Software should check this bit is 0 before changing channel configuration."]
pub type VcBusyW<'a, REG> = crate::BitWriter<'a, REG, VcBusy>;
impl<'a, REG> VcBusyW<'a, REG>
where
    REG: crate::Writable + crate::RegisterSpec,
{
    #[doc = "No pending operations for this VC"]
    #[inline(always)]
    pub fn completed(self) -> &'a mut crate::W<REG> {
        self.variant(VcBusy::Completed)
    }
    #[doc = "Pending operations for this VC"]
    #[inline(always)]
    pub fn busy(self) -> &'a mut crate::W<REG> {
        self.variant(VcBusy::Busy)
    }
}
#[doc = "16:16\\]
FIFO status\n\nValue on reset: 0"]
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub enum TxFifoFull {
    #[doc = "0: The TX FIFO is not full (the FIFO can accept at least one more 32-bit valuel)"]
    NotFull = 0,
    #[doc = "1: The TX FIFO is full"]
    Full = 1,
}
impl From<TxFifoFull> for bool {
    #[inline(always)]
    fn from(variant: TxFifoFull) -> Self {
        variant as u8 != 0
    }
}
#[doc = "Field `TX_FIFO_FULL` reader - 16:16\\]
FIFO status"]
pub type TxFifoFullR = crate::BitReader<TxFifoFull>;
impl TxFifoFullR {
    #[doc = "Get enumerated values variant"]
    #[inline(always)]
    pub const fn variant(&self) -> TxFifoFull {
        match self.bits {
            false => TxFifoFull::NotFull,
            true => TxFifoFull::Full,
        }
    }
    #[doc = "The TX FIFO is not full (the FIFO can accept at least one more 32-bit valuel)"]
    #[inline(always)]
    pub fn is_not_full(&self) -> bool {
        *self == TxFifoFull::NotFull
    }
    #[doc = "The TX FIFO is full"]
    #[inline(always)]
    pub fn is_full(&self) -> bool {
        *self == TxFifoFull::Full
    }
}
#[doc = "Field `TX_FIFO_FULL` writer - 16:16\\]
FIFO status"]
pub type TxFifoFullW<'a, REG> = crate::BitWriter<'a, REG, TxFifoFull>;
impl<'a, REG> TxFifoFullW<'a, REG>
where
    REG: crate::Writable + crate::RegisterSpec,
{
    #[doc = "The TX FIFO is not full (the FIFO can accept at least one more 32-bit valuel)"]
    #[inline(always)]
    pub fn not_full(self) -> &'a mut crate::W<REG> {
        self.variant(TxFifoFull::NotFull)
    }
    #[doc = "The TX FIFO is full"]
    #[inline(always)]
    pub fn full(self) -> &'a mut crate::W<REG> {
        self.variant(TxFifoFull::Full)
    }
}
#[doc = "19:17\\]
Defines the threshold value for the DMA request (associated to the TX FIFO)\n\nValue on reset: 0"]
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
#[repr(u8)]
pub enum DmaTxThreshold {
    #[doc = "0: 1x 32 bits"]
    F1 = 0,
    #[doc = "1: 2 x 32 bits"]
    F2 = 1,
    #[doc = "2: 4 x 32 bits"]
    F4 = 2,
    #[doc = "3: 8 x 32 bits"]
    F8 = 3,
    #[doc = "4: 16 x 32 bits"]
    F16 = 4,
    #[doc = "5: 32 x 32 bits"]
    F32 = 5,
}
impl From<DmaTxThreshold> for u8 {
    #[inline(always)]
    fn from(variant: DmaTxThreshold) -> Self {
        variant as _
    }
}
impl crate::FieldSpec for DmaTxThreshold {
    type Ux = u8;
}
impl crate::IsEnum for DmaTxThreshold {}
#[doc = "Field `DMA_TX_THRESHOLD` reader - 19:17\\]
Defines the threshold value for the DMA request (associated to the TX FIFO)"]
pub type DmaTxThresholdR = crate::FieldReader<DmaTxThreshold>;
impl DmaTxThresholdR {
    #[doc = "Get enumerated values variant"]
    #[inline(always)]
    pub const fn variant(&self) -> Option<DmaTxThreshold> {
        match self.bits {
            0 => Some(DmaTxThreshold::F1),
            1 => Some(DmaTxThreshold::F2),
            2 => Some(DmaTxThreshold::F4),
            3 => Some(DmaTxThreshold::F8),
            4 => Some(DmaTxThreshold::F16),
            5 => Some(DmaTxThreshold::F32),
            _ => None,
        }
    }
    #[doc = "1x 32 bits"]
    #[inline(always)]
    pub fn is_f1(&self) -> bool {
        *self == DmaTxThreshold::F1
    }
    #[doc = "2 x 32 bits"]
    #[inline(always)]
    pub fn is_f2(&self) -> bool {
        *self == DmaTxThreshold::F2
    }
    #[doc = "4 x 32 bits"]
    #[inline(always)]
    pub fn is_f4(&self) -> bool {
        *self == DmaTxThreshold::F4
    }
    #[doc = "8 x 32 bits"]
    #[inline(always)]
    pub fn is_f8(&self) -> bool {
        *self == DmaTxThreshold::F8
    }
    #[doc = "16 x 32 bits"]
    #[inline(always)]
    pub fn is_f16(&self) -> bool {
        *self == DmaTxThreshold::F16
    }
    #[doc = "32 x 32 bits"]
    #[inline(always)]
    pub fn is_f32(&self) -> bool {
        *self == DmaTxThreshold::F32
    }
}
#[doc = "Field `DMA_TX_THRESHOLD` writer - 19:17\\]
Defines the threshold value for the DMA request (associated to the TX FIFO)"]
pub type DmaTxThresholdW<'a, REG> = crate::FieldWriter<'a, REG, 3, DmaTxThreshold>;
impl<'a, REG> DmaTxThresholdW<'a, REG>
where
    REG: crate::Writable + crate::RegisterSpec,
    REG::Ux: From<u8>,
{
    #[doc = "1x 32 bits"]
    #[inline(always)]
    pub fn f1(self) -> &'a mut crate::W<REG> {
        self.variant(DmaTxThreshold::F1)
    }
    #[doc = "2 x 32 bits"]
    #[inline(always)]
    pub fn f2(self) -> &'a mut crate::W<REG> {
        self.variant(DmaTxThreshold::F2)
    }
    #[doc = "4 x 32 bits"]
    #[inline(always)]
    pub fn f4(self) -> &'a mut crate::W<REG> {
        self.variant(DmaTxThreshold::F4)
    }
    #[doc = "8 x 32 bits"]
    #[inline(always)]
    pub fn f8(self) -> &'a mut crate::W<REG> {
        self.variant(DmaTxThreshold::F8)
    }
    #[doc = "16 x 32 bits"]
    #[inline(always)]
    pub fn f16(self) -> &'a mut crate::W<REG> {
        self.variant(DmaTxThreshold::F16)
    }
    #[doc = "32 x 32 bits"]
    #[inline(always)]
    pub fn f32(self) -> &'a mut crate::W<REG> {
        self.variant(DmaTxThreshold::F32)
    }
}
#[doc = "20:20\\]
FIFO status\n\nValue on reset: 0"]
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub enum RxFifoNotEmpty {
    #[doc = "0: The RX FIFO is empty (the FIFO does not contain any data for the virtual channel)"]
    Empty = 0,
    #[doc = "1: The RX FIFO is not empty (the FIFO contains at least one byte for the virtual channel)"]
    NotEmpty = 1,
}
impl From<RxFifoNotEmpty> for bool {
    #[inline(always)]
    fn from(variant: RxFifoNotEmpty) -> Self {
        variant as u8 != 0
    }
}
#[doc = "Field `RX_FIFO_NOT_EMPTY` reader - 20:20\\]
FIFO status"]
pub type RxFifoNotEmptyR = crate::BitReader<RxFifoNotEmpty>;
impl RxFifoNotEmptyR {
    #[doc = "Get enumerated values variant"]
    #[inline(always)]
    pub const fn variant(&self) -> RxFifoNotEmpty {
        match self.bits {
            false => RxFifoNotEmpty::Empty,
            true => RxFifoNotEmpty::NotEmpty,
        }
    }
    #[doc = "The RX FIFO is empty (the FIFO does not contain any data for the virtual channel)"]
    #[inline(always)]
    pub fn is_empty(&self) -> bool {
        *self == RxFifoNotEmpty::Empty
    }
    #[doc = "The RX FIFO is not empty (the FIFO contains at least one byte for the virtual channel)"]
    #[inline(always)]
    pub fn is_not_empty(&self) -> bool {
        *self == RxFifoNotEmpty::NotEmpty
    }
}
#[doc = "Field `RX_FIFO_NOT_EMPTY` writer - 20:20\\]
FIFO status"]
pub type RxFifoNotEmptyW<'a, REG> = crate::BitWriter<'a, REG, RxFifoNotEmpty>;
impl<'a, REG> RxFifoNotEmptyW<'a, REG>
where
    REG: crate::Writable + crate::RegisterSpec,
{
    #[doc = "The RX FIFO is empty (the FIFO does not contain any data for the virtual channel)"]
    #[inline(always)]
    pub fn empty(self) -> &'a mut crate::W<REG> {
        self.variant(RxFifoNotEmpty::Empty)
    }
    #[doc = "The RX FIFO is not empty (the FIFO contains at least one byte for the virtual channel)"]
    #[inline(always)]
    pub fn not_empty(self) -> &'a mut crate::W<REG> {
        self.variant(RxFifoNotEmpty::NotEmpty)
    }
}
#[doc = "23:21\\]
Selection of the use of the DMA request (associated to the TX FIFO)\n\nValue on reset: 0"]
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
#[repr(u8)]
pub enum DmaTxReqNb {
    #[doc = "0: DMA_req0 is selected (valid only if CSI2_GNQ.NB_DMA_REQUEST is greater than 0)"]
    DmaReq0 = 0,
    #[doc = "1: DMA_req1 is selected (valid only if CSI2_GNQ.NB_DMA_REQUEST is greater than 1)"]
    DmaReq1 = 1,
    #[doc = "2: DMA_req2 is selected (valid only if CSI2_GNQ.NB_DMA_REQUEST is greater than 2)"]
    DmaReq2 = 2,
    #[doc = "3: DMA_req3 is selected (valid only if CSI2_GNQ.NB_DMA_REQUEST is equal to 3)"]
    DmaReq3 = 3,
    #[doc = "4: No DMA req selected"]
    NoDmaReq = 4,
}
impl From<DmaTxReqNb> for u8 {
    #[inline(always)]
    fn from(variant: DmaTxReqNb) -> Self {
        variant as _
    }
}
impl crate::FieldSpec for DmaTxReqNb {
    type Ux = u8;
}
impl crate::IsEnum for DmaTxReqNb {}
#[doc = "Field `DMA_TX_REQ_NB` reader - 23:21\\]
Selection of the use of the DMA request (associated to the TX FIFO)"]
pub type DmaTxReqNbR = crate::FieldReader<DmaTxReqNb>;
impl DmaTxReqNbR {
    #[doc = "Get enumerated values variant"]
    #[inline(always)]
    pub const fn variant(&self) -> Option<DmaTxReqNb> {
        match self.bits {
            0 => Some(DmaTxReqNb::DmaReq0),
            1 => Some(DmaTxReqNb::DmaReq1),
            2 => Some(DmaTxReqNb::DmaReq2),
            3 => Some(DmaTxReqNb::DmaReq3),
            4 => Some(DmaTxReqNb::NoDmaReq),
            _ => None,
        }
    }
    #[doc = "DMA_req0 is selected (valid only if CSI2_GNQ.NB_DMA_REQUEST is greater than 0)"]
    #[inline(always)]
    pub fn is_dma_req0(&self) -> bool {
        *self == DmaTxReqNb::DmaReq0
    }
    #[doc = "DMA_req1 is selected (valid only if CSI2_GNQ.NB_DMA_REQUEST is greater than 1)"]
    #[inline(always)]
    pub fn is_dma_req1(&self) -> bool {
        *self == DmaTxReqNb::DmaReq1
    }
    #[doc = "DMA_req2 is selected (valid only if CSI2_GNQ.NB_DMA_REQUEST is greater than 2)"]
    #[inline(always)]
    pub fn is_dma_req2(&self) -> bool {
        *self == DmaTxReqNb::DmaReq2
    }
    #[doc = "DMA_req3 is selected (valid only if CSI2_GNQ.NB_DMA_REQUEST is equal to 3)"]
    #[inline(always)]
    pub fn is_dma_req3(&self) -> bool {
        *self == DmaTxReqNb::DmaReq3
    }
    #[doc = "No DMA req selected"]
    #[inline(always)]
    pub fn is_no_dma_req(&self) -> bool {
        *self == DmaTxReqNb::NoDmaReq
    }
}
#[doc = "Field `DMA_TX_REQ_NB` writer - 23:21\\]
Selection of the use of the DMA request (associated to the TX FIFO)"]
pub type DmaTxReqNbW<'a, REG> = crate::FieldWriter<'a, REG, 3, DmaTxReqNb>;
impl<'a, REG> DmaTxReqNbW<'a, REG>
where
    REG: crate::Writable + crate::RegisterSpec,
    REG::Ux: From<u8>,
{
    #[doc = "DMA_req0 is selected (valid only if CSI2_GNQ.NB_DMA_REQUEST is greater than 0)"]
    #[inline(always)]
    pub fn dma_req0(self) -> &'a mut crate::W<REG> {
        self.variant(DmaTxReqNb::DmaReq0)
    }
    #[doc = "DMA_req1 is selected (valid only if CSI2_GNQ.NB_DMA_REQUEST is greater than 1)"]
    #[inline(always)]
    pub fn dma_req1(self) -> &'a mut crate::W<REG> {
        self.variant(DmaTxReqNb::DmaReq1)
    }
    #[doc = "DMA_req2 is selected (valid only if CSI2_GNQ.NB_DMA_REQUEST is greater than 2)"]
    #[inline(always)]
    pub fn dma_req2(self) -> &'a mut crate::W<REG> {
        self.variant(DmaTxReqNb::DmaReq2)
    }
    #[doc = "DMA_req3 is selected (valid only if CSI2_GNQ.NB_DMA_REQUEST is equal to 3)"]
    #[inline(always)]
    pub fn dma_req3(self) -> &'a mut crate::W<REG> {
        self.variant(DmaTxReqNb::DmaReq3)
    }
    #[doc = "No DMA req selected"]
    #[inline(always)]
    pub fn no_dma_req(self) -> &'a mut crate::W<REG> {
        self.variant(DmaTxReqNb::NoDmaReq)
    }
}
#[doc = "26:24\\]
Defines the threshold value for the DMA request (associated to the RX FIFO)\n\nValue on reset: 0"]
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
#[repr(u8)]
pub enum DmaRxThreshold {
    #[doc = "0: 1x 32 bits"]
    F1 = 0,
    #[doc = "1: 2 x 32 bits"]
    F2 = 1,
    #[doc = "2: 4 x 32 bits"]
    F4 = 2,
    #[doc = "3: 8 x 32 bits"]
    F8 = 3,
    #[doc = "4: 16 x 32 bits"]
    F16 = 4,
    #[doc = "5: 32 x 32 bits"]
    F32 = 5,
}
impl From<DmaRxThreshold> for u8 {
    #[inline(always)]
    fn from(variant: DmaRxThreshold) -> Self {
        variant as _
    }
}
impl crate::FieldSpec for DmaRxThreshold {
    type Ux = u8;
}
impl crate::IsEnum for DmaRxThreshold {}
#[doc = "Field `DMA_RX_THRESHOLD` reader - 26:24\\]
Defines the threshold value for the DMA request (associated to the RX FIFO)"]
pub type DmaRxThresholdR = crate::FieldReader<DmaRxThreshold>;
impl DmaRxThresholdR {
    #[doc = "Get enumerated values variant"]
    #[inline(always)]
    pub const fn variant(&self) -> Option<DmaRxThreshold> {
        match self.bits {
            0 => Some(DmaRxThreshold::F1),
            1 => Some(DmaRxThreshold::F2),
            2 => Some(DmaRxThreshold::F4),
            3 => Some(DmaRxThreshold::F8),
            4 => Some(DmaRxThreshold::F16),
            5 => Some(DmaRxThreshold::F32),
            _ => None,
        }
    }
    #[doc = "1x 32 bits"]
    #[inline(always)]
    pub fn is_f1(&self) -> bool {
        *self == DmaRxThreshold::F1
    }
    #[doc = "2 x 32 bits"]
    #[inline(always)]
    pub fn is_f2(&self) -> bool {
        *self == DmaRxThreshold::F2
    }
    #[doc = "4 x 32 bits"]
    #[inline(always)]
    pub fn is_f4(&self) -> bool {
        *self == DmaRxThreshold::F4
    }
    #[doc = "8 x 32 bits"]
    #[inline(always)]
    pub fn is_f8(&self) -> bool {
        *self == DmaRxThreshold::F8
    }
    #[doc = "16 x 32 bits"]
    #[inline(always)]
    pub fn is_f16(&self) -> bool {
        *self == DmaRxThreshold::F16
    }
    #[doc = "32 x 32 bits"]
    #[inline(always)]
    pub fn is_f32(&self) -> bool {
        *self == DmaRxThreshold::F32
    }
}
#[doc = "Field `DMA_RX_THRESHOLD` writer - 26:24\\]
Defines the threshold value for the DMA request (associated to the RX FIFO)"]
pub type DmaRxThresholdW<'a, REG> = crate::FieldWriter<'a, REG, 3, DmaRxThreshold>;
impl<'a, REG> DmaRxThresholdW<'a, REG>
where
    REG: crate::Writable + crate::RegisterSpec,
    REG::Ux: From<u8>,
{
    #[doc = "1x 32 bits"]
    #[inline(always)]
    pub fn f1(self) -> &'a mut crate::W<REG> {
        self.variant(DmaRxThreshold::F1)
    }
    #[doc = "2 x 32 bits"]
    #[inline(always)]
    pub fn f2(self) -> &'a mut crate::W<REG> {
        self.variant(DmaRxThreshold::F2)
    }
    #[doc = "4 x 32 bits"]
    #[inline(always)]
    pub fn f4(self) -> &'a mut crate::W<REG> {
        self.variant(DmaRxThreshold::F4)
    }
    #[doc = "8 x 32 bits"]
    #[inline(always)]
    pub fn f8(self) -> &'a mut crate::W<REG> {
        self.variant(DmaRxThreshold::F8)
    }
    #[doc = "16 x 32 bits"]
    #[inline(always)]
    pub fn f16(self) -> &'a mut crate::W<REG> {
        self.variant(DmaRxThreshold::F16)
    }
    #[doc = "32 x 32 bits"]
    #[inline(always)]
    pub fn f32(self) -> &'a mut crate::W<REG> {
        self.variant(DmaRxThreshold::F32)
    }
}
#[doc = "29:27\\]
Selection of the use of the DMA request (associated to the RX FIFO)\n\nValue on reset: 0"]
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
#[repr(u8)]
pub enum DmaRxReqNb {
    #[doc = "0: DMA_req0 is selected (valid only if CSI2_GNQ.NB_DMA_REQUEST is greater than 0)"]
    DmaReq0 = 0,
    #[doc = "1: DMA_req1 is selected (valid only if CSI2_GNQ.NB_DMA_REQUEST is greater than 1)"]
    DmaReq1 = 1,
    #[doc = "2: DMA_req2 is selected (valid only if CSI2_GNQ.NB_DMA_REQUEST is greater than 2)"]
    DmaReq2 = 2,
    #[doc = "3: DMA_req3 is selected (valid only if CSI2_GNQ.NB_DMA_REQUEST is equal to 3)"]
    DmaReq3 = 3,
    #[doc = "4: No DMA req selected"]
    NoDmaReq = 4,
}
impl From<DmaRxReqNb> for u8 {
    #[inline(always)]
    fn from(variant: DmaRxReqNb) -> Self {
        variant as _
    }
}
impl crate::FieldSpec for DmaRxReqNb {
    type Ux = u8;
}
impl crate::IsEnum for DmaRxReqNb {}
#[doc = "Field `DMA_RX_REQ_NB` reader - 29:27\\]
Selection of the use of the DMA request (associated to the RX FIFO)"]
pub type DmaRxReqNbR = crate::FieldReader<DmaRxReqNb>;
impl DmaRxReqNbR {
    #[doc = "Get enumerated values variant"]
    #[inline(always)]
    pub const fn variant(&self) -> Option<DmaRxReqNb> {
        match self.bits {
            0 => Some(DmaRxReqNb::DmaReq0),
            1 => Some(DmaRxReqNb::DmaReq1),
            2 => Some(DmaRxReqNb::DmaReq2),
            3 => Some(DmaRxReqNb::DmaReq3),
            4 => Some(DmaRxReqNb::NoDmaReq),
            _ => None,
        }
    }
    #[doc = "DMA_req0 is selected (valid only if CSI2_GNQ.NB_DMA_REQUEST is greater than 0)"]
    #[inline(always)]
    pub fn is_dma_req0(&self) -> bool {
        *self == DmaRxReqNb::DmaReq0
    }
    #[doc = "DMA_req1 is selected (valid only if CSI2_GNQ.NB_DMA_REQUEST is greater than 1)"]
    #[inline(always)]
    pub fn is_dma_req1(&self) -> bool {
        *self == DmaRxReqNb::DmaReq1
    }
    #[doc = "DMA_req2 is selected (valid only if CSI2_GNQ.NB_DMA_REQUEST is greater than 2)"]
    #[inline(always)]
    pub fn is_dma_req2(&self) -> bool {
        *self == DmaRxReqNb::DmaReq2
    }
    #[doc = "DMA_req3 is selected (valid only if CSI2_GNQ.NB_DMA_REQUEST is equal to 3)"]
    #[inline(always)]
    pub fn is_dma_req3(&self) -> bool {
        *self == DmaRxReqNb::DmaReq3
    }
    #[doc = "No DMA req selected"]
    #[inline(always)]
    pub fn is_no_dma_req(&self) -> bool {
        *self == DmaRxReqNb::NoDmaReq
    }
}
#[doc = "Field `DMA_RX_REQ_NB` writer - 29:27\\]
Selection of the use of the DMA request (associated to the RX FIFO)"]
pub type DmaRxReqNbW<'a, REG> = crate::FieldWriter<'a, REG, 3, DmaRxReqNb>;
impl<'a, REG> DmaRxReqNbW<'a, REG>
where
    REG: crate::Writable + crate::RegisterSpec,
    REG::Ux: From<u8>,
{
    #[doc = "DMA_req0 is selected (valid only if CSI2_GNQ.NB_DMA_REQUEST is greater than 0)"]
    #[inline(always)]
    pub fn dma_req0(self) -> &'a mut crate::W<REG> {
        self.variant(DmaRxReqNb::DmaReq0)
    }
    #[doc = "DMA_req1 is selected (valid only if CSI2_GNQ.NB_DMA_REQUEST is greater than 1)"]
    #[inline(always)]
    pub fn dma_req1(self) -> &'a mut crate::W<REG> {
        self.variant(DmaRxReqNb::DmaReq1)
    }
    #[doc = "DMA_req2 is selected (valid only if CSI2_GNQ.NB_DMA_REQUEST is greater than 2)"]
    #[inline(always)]
    pub fn dma_req2(self) -> &'a mut crate::W<REG> {
        self.variant(DmaRxReqNb::DmaReq2)
    }
    #[doc = "DMA_req3 is selected (valid only if CSI2_GNQ.NB_DMA_REQUEST is equal to 3)"]
    #[inline(always)]
    pub fn dma_req3(self) -> &'a mut crate::W<REG> {
        self.variant(DmaRxReqNb::DmaReq3)
    }
    #[doc = "No DMA req selected"]
    #[inline(always)]
    pub fn no_dma_req(self) -> &'a mut crate::W<REG> {
        self.variant(DmaRxReqNb::NoDmaReq)
    }
}
#[doc = "30:30\\]
Enables automatic insertion of DCS command codes when data is sourced by the video port.\n\nValue on reset: 0"]
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub enum DcsCmdEnable {
    #[doc = "0: DCS command code is NOT inserted when command mode traffic is coming from the Video Port or OCP slave port."]
    DcsDisable = 0,
    #[doc = "1: DCS command code is inserted automatically when command mode traffic is coming from the Video Port or OCP slave port."]
    DcsEnable = 1,
}
impl From<DcsCmdEnable> for bool {
    #[inline(always)]
    fn from(variant: DcsCmdEnable) -> Self {
        variant as u8 != 0
    }
}
#[doc = "Field `DCS_CMD_ENABLE` reader - 30:30\\]
Enables automatic insertion of DCS command codes when data is sourced by the video port."]
pub type DcsCmdEnableR = crate::BitReader<DcsCmdEnable>;
impl DcsCmdEnableR {
    #[doc = "Get enumerated values variant"]
    #[inline(always)]
    pub const fn variant(&self) -> DcsCmdEnable {
        match self.bits {
            false => DcsCmdEnable::DcsDisable,
            true => DcsCmdEnable::DcsEnable,
        }
    }
    #[doc = "DCS command code is NOT inserted when command mode traffic is coming from the Video Port or OCP slave port."]
    #[inline(always)]
    pub fn is_dcs_disable(&self) -> bool {
        *self == DcsCmdEnable::DcsDisable
    }
    #[doc = "DCS command code is inserted automatically when command mode traffic is coming from the Video Port or OCP slave port."]
    #[inline(always)]
    pub fn is_dcs_enable(&self) -> bool {
        *self == DcsCmdEnable::DcsEnable
    }
}
#[doc = "Field `DCS_CMD_ENABLE` writer - 30:30\\]
Enables automatic insertion of DCS command codes when data is sourced by the video port."]
pub type DcsCmdEnableW<'a, REG> = crate::BitWriter<'a, REG, DcsCmdEnable>;
impl<'a, REG> DcsCmdEnableW<'a, REG>
where
    REG: crate::Writable + crate::RegisterSpec,
{
    #[doc = "DCS command code is NOT inserted when command mode traffic is coming from the Video Port or OCP slave port."]
    #[inline(always)]
    pub fn dcs_disable(self) -> &'a mut crate::W<REG> {
        self.variant(DcsCmdEnable::DcsDisable)
    }
    #[doc = "DCS command code is inserted automatically when command mode traffic is coming from the Video Port or OCP slave port."]
    #[inline(always)]
    pub fn dcs_enable(self) -> &'a mut crate::W<REG> {
        self.variant(DcsCmdEnable::DcsEnable)
    }
}
#[doc = "31:31\\]
DCS command code value to insert between header and video port or OCP slave data when enabled by DCS_CMD_ENABLE (only when TE mechanism is not used otherwise the bit-field DCS_CMD_CODE is ignored by CSI2 protocol engine).\n\nValue on reset: 0"]
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub enum DcsCmdCode {
    #[doc = "0: DCS write memory continue code is inserted."]
    DcsContinue = 0,
    #[doc = "1: DCS write memory start code is inserted."]
    DcsStart = 1,
}
impl From<DcsCmdCode> for bool {
    #[inline(always)]
    fn from(variant: DcsCmdCode) -> Self {
        variant as u8 != 0
    }
}
#[doc = "Field `DCS_CMD_CODE` reader - 31:31\\]
DCS command code value to insert between header and video port or OCP slave data when enabled by DCS_CMD_ENABLE (only when TE mechanism is not used otherwise the bit-field DCS_CMD_CODE is ignored by CSI2 protocol engine)."]
pub type DcsCmdCodeR = crate::BitReader<DcsCmdCode>;
impl DcsCmdCodeR {
    #[doc = "Get enumerated values variant"]
    #[inline(always)]
    pub const fn variant(&self) -> DcsCmdCode {
        match self.bits {
            false => DcsCmdCode::DcsContinue,
            true => DcsCmdCode::DcsStart,
        }
    }
    #[doc = "DCS write memory continue code is inserted."]
    #[inline(always)]
    pub fn is_dcs_continue(&self) -> bool {
        *self == DcsCmdCode::DcsContinue
    }
    #[doc = "DCS write memory start code is inserted."]
    #[inline(always)]
    pub fn is_dcs_start(&self) -> bool {
        *self == DcsCmdCode::DcsStart
    }
}
#[doc = "Field `DCS_CMD_CODE` writer - 31:31\\]
DCS command code value to insert between header and video port or OCP slave data when enabled by DCS_CMD_ENABLE (only when TE mechanism is not used otherwise the bit-field DCS_CMD_CODE is ignored by CSI2 protocol engine)."]
pub type DcsCmdCodeW<'a, REG> = crate::BitWriter<'a, REG, DcsCmdCode>;
impl<'a, REG> DcsCmdCodeW<'a, REG>
where
    REG: crate::Writable + crate::RegisterSpec,
{
    #[doc = "DCS write memory continue code is inserted."]
    #[inline(always)]
    pub fn dcs_continue(self) -> &'a mut crate::W<REG> {
        self.variant(DcsCmdCode::DcsContinue)
    }
    #[doc = "DCS write memory start code is inserted."]
    #[inline(always)]
    pub fn dcs_start(self) -> &'a mut crate::W<REG> {
        self.variant(DcsCmdCode::DcsStart)
    }
}
impl R {
    #[doc = "Bit 0 - 0:0\\]
Enables the virtual channel."]
    #[inline(always)]
    pub fn vc_en(&self) -> VcEnR {
        VcEnR::new((self.bits & 1) != 0)
    }
    #[doc = "Bit 1 - 1:1\\]
Selection of the source between OCP and the Video port(s) (used by the HW only if MODE=COMMAND MODE (0x0) otherwise it is ignored). The number of available video ports is defined in CSI2_GNQ.NB_VIDEO_PORTS."]
    #[inline(always)]
    pub fn source(&self) -> SourceR {
        SourceR::new(((self.bits >> 1) & 1) != 0)
    }
    #[doc = "Bit 2 - 2:2\\]
Enables the automatic bus turn-around after completion of each short packet transmission."]
    #[inline(always)]
    pub fn bta_short_en(&self) -> BtaShortEnR {
        BtaShortEnR::new(((self.bits >> 2) & 1) != 0)
    }
    #[doc = "Bit 3 - 3:3\\]
Enables the automatic bus turn-around after completion of each long packet transmission."]
    #[inline(always)]
    pub fn bta_long_en(&self) -> BtaLongEnR {
        BtaLongEnR::new(((self.bits >> 3) & 1) != 0)
    }
    #[doc = "Bit 4 - 4:4\\]
Selection of the mode"]
    #[inline(always)]
    pub fn mode(&self) -> ModeR {
        ModeR::new(((self.bits >> 4) & 1) != 0)
    }
    #[doc = "Bit 5 - 5:5\\]
FIFO status"]
    #[inline(always)]
    pub fn tx_fifo_not_empty(&self) -> TxFifoNotEmptyR {
        TxFifoNotEmptyR::new(((self.bits >> 5) & 1) != 0)
    }
    #[doc = "Bit 6 - 6:6\\]
Send the bus turn around to the peripheral. It can be used when the automatic mode is enabled (BTA_SHORT_EN=1 or/and BTA_LONG_EN=1). In that case only one BTA is sent to the peripheral. The manual mode is used to allow the user to define for which packets, the turn around is required for example getting acknowledge from the peripheral."]
    #[inline(always)]
    pub fn bta_en(&self) -> BtaEnR {
        BtaEnR::new(((self.bits >> 6) & 1) != 0)
    }
    #[doc = "Bit 7 - 7:7\\]
Enables the checksum generation for the transmit payload (long packet only)."]
    #[inline(always)]
    pub fn cs_tx_en(&self) -> CsTxEnR {
        CsTxEnR::new(((self.bits >> 7) & 1) != 0)
    }
    #[doc = "Bit 8 - 8:8\\]
Enables the Error Correction Code generation for the transmit header (short and long packets)."]
    #[inline(always)]
    pub fn ecc_tx_en(&self) -> EccTxEnR {
        EccTxEnR::new(((self.bits >> 8) & 1) != 0)
    }
    #[doc = "Bit 9 - 9:9\\]
Selection of the mode. The information is used by HW only if MODE=COMMAND_MODE otherwise it is ignored."]
    #[inline(always)]
    pub fn mode_speed(&self) -> ModeSpeedR {
        ModeSpeedR::new(((self.bits >> 9) & 1) != 0)
    }
    #[doc = "Bits 10:11 - 11:10\\]
Defines the size of the OCP data bus"]
    #[inline(always)]
    pub fn ocp_data_bus_width(&self) -> OcpDataBusWidthR {
        OcpDataBusWidthR::new(((self.bits >> 10) & 3) as u8)
    }
    #[doc = "Bit 12 - 12:12\\]
Byte order for RBG565"]
    #[inline(always)]
    pub fn rgb565_order(&self) -> Rgb565OrderR {
        Rgb565OrderR::new(((self.bits >> 12) & 1) != 0)
    }
    #[doc = "Bit 13 - 13:13\\]
Selection between video port 1 and video port 2. If CSI2_GNQ.NB_VIDEO_PORTS=0, the bit-field is ignored since only video port 1 is present."]
    #[inline(always)]
    pub fn vp_source(&self) -> VpSourceR {
        VpSourceR::new(((self.bits >> 13) & 1) != 0)
    }
    #[doc = "Bit 14 - 14:14\\]
Ping-pong buffer busy status."]
    #[inline(always)]
    pub fn pp_busy(&self) -> PpBusyR {
        PpBusyR::new(((self.bits >> 14) & 1) != 0)
    }
    #[doc = "Bit 15 - 15:15\\]
Indicates if previously scheduled activities (packets, BTA) are still being processed. Forced to 1 if VC is enabled. Software should check this bit is 0 before changing channel configuration."]
    #[inline(always)]
    pub fn vc_busy(&self) -> VcBusyR {
        VcBusyR::new(((self.bits >> 15) & 1) != 0)
    }
    #[doc = "Bit 16 - 16:16\\]
FIFO status"]
    #[inline(always)]
    pub fn tx_fifo_full(&self) -> TxFifoFullR {
        TxFifoFullR::new(((self.bits >> 16) & 1) != 0)
    }
    #[doc = "Bits 17:19 - 19:17\\]
Defines the threshold value for the DMA request (associated to the TX FIFO)"]
    #[inline(always)]
    pub fn dma_tx_threshold(&self) -> DmaTxThresholdR {
        DmaTxThresholdR::new(((self.bits >> 17) & 7) as u8)
    }
    #[doc = "Bit 20 - 20:20\\]
FIFO status"]
    #[inline(always)]
    pub fn rx_fifo_not_empty(&self) -> RxFifoNotEmptyR {
        RxFifoNotEmptyR::new(((self.bits >> 20) & 1) != 0)
    }
    #[doc = "Bits 21:23 - 23:21\\]
Selection of the use of the DMA request (associated to the TX FIFO)"]
    #[inline(always)]
    pub fn dma_tx_req_nb(&self) -> DmaTxReqNbR {
        DmaTxReqNbR::new(((self.bits >> 21) & 7) as u8)
    }
    #[doc = "Bits 24:26 - 26:24\\]
Defines the threshold value for the DMA request (associated to the RX FIFO)"]
    #[inline(always)]
    pub fn dma_rx_threshold(&self) -> DmaRxThresholdR {
        DmaRxThresholdR::new(((self.bits >> 24) & 7) as u8)
    }
    #[doc = "Bits 27:29 - 29:27\\]
Selection of the use of the DMA request (associated to the RX FIFO)"]
    #[inline(always)]
    pub fn dma_rx_req_nb(&self) -> DmaRxReqNbR {
        DmaRxReqNbR::new(((self.bits >> 27) & 7) as u8)
    }
    #[doc = "Bit 30 - 30:30\\]
Enables automatic insertion of DCS command codes when data is sourced by the video port."]
    #[inline(always)]
    pub fn dcs_cmd_enable(&self) -> DcsCmdEnableR {
        DcsCmdEnableR::new(((self.bits >> 30) & 1) != 0)
    }
    #[doc = "Bit 31 - 31:31\\]
DCS command code value to insert between header and video port or OCP slave data when enabled by DCS_CMD_ENABLE (only when TE mechanism is not used otherwise the bit-field DCS_CMD_CODE is ignored by CSI2 protocol engine)."]
    #[inline(always)]
    pub fn dcs_cmd_code(&self) -> DcsCmdCodeR {
        DcsCmdCodeR::new(((self.bits >> 31) & 1) != 0)
    }
}
impl W {
    #[doc = "Bit 0 - 0:0\\]
Enables the virtual channel."]
    #[inline(always)]
    #[must_use]
    pub fn vc_en(&mut self) -> VcEnW<Csi2VcCtrl2Spec> {
        VcEnW::new(self, 0)
    }
    #[doc = "Bit 1 - 1:1\\]
Selection of the source between OCP and the Video port(s) (used by the HW only if MODE=COMMAND MODE (0x0) otherwise it is ignored). The number of available video ports is defined in CSI2_GNQ.NB_VIDEO_PORTS."]
    #[inline(always)]
    #[must_use]
    pub fn source(&mut self) -> SourceW<Csi2VcCtrl2Spec> {
        SourceW::new(self, 1)
    }
    #[doc = "Bit 2 - 2:2\\]
Enables the automatic bus turn-around after completion of each short packet transmission."]
    #[inline(always)]
    #[must_use]
    pub fn bta_short_en(&mut self) -> BtaShortEnW<Csi2VcCtrl2Spec> {
        BtaShortEnW::new(self, 2)
    }
    #[doc = "Bit 3 - 3:3\\]
Enables the automatic bus turn-around after completion of each long packet transmission."]
    #[inline(always)]
    #[must_use]
    pub fn bta_long_en(&mut self) -> BtaLongEnW<Csi2VcCtrl2Spec> {
        BtaLongEnW::new(self, 3)
    }
    #[doc = "Bit 4 - 4:4\\]
Selection of the mode"]
    #[inline(always)]
    #[must_use]
    pub fn mode(&mut self) -> ModeW<Csi2VcCtrl2Spec> {
        ModeW::new(self, 4)
    }
    #[doc = "Bit 5 - 5:5\\]
FIFO status"]
    #[inline(always)]
    #[must_use]
    pub fn tx_fifo_not_empty(&mut self) -> TxFifoNotEmptyW<Csi2VcCtrl2Spec> {
        TxFifoNotEmptyW::new(self, 5)
    }
    #[doc = "Bit 6 - 6:6\\]
Send the bus turn around to the peripheral. It can be used when the automatic mode is enabled (BTA_SHORT_EN=1 or/and BTA_LONG_EN=1). In that case only one BTA is sent to the peripheral. The manual mode is used to allow the user to define for which packets, the turn around is required for example getting acknowledge from the peripheral."]
    #[inline(always)]
    #[must_use]
    pub fn bta_en(&mut self) -> BtaEnW<Csi2VcCtrl2Spec> {
        BtaEnW::new(self, 6)
    }
    #[doc = "Bit 7 - 7:7\\]
Enables the checksum generation for the transmit payload (long packet only)."]
    #[inline(always)]
    #[must_use]
    pub fn cs_tx_en(&mut self) -> CsTxEnW<Csi2VcCtrl2Spec> {
        CsTxEnW::new(self, 7)
    }
    #[doc = "Bit 8 - 8:8\\]
Enables the Error Correction Code generation for the transmit header (short and long packets)."]
    #[inline(always)]
    #[must_use]
    pub fn ecc_tx_en(&mut self) -> EccTxEnW<Csi2VcCtrl2Spec> {
        EccTxEnW::new(self, 8)
    }
    #[doc = "Bit 9 - 9:9\\]
Selection of the mode. The information is used by HW only if MODE=COMMAND_MODE otherwise it is ignored."]
    #[inline(always)]
    #[must_use]
    pub fn mode_speed(&mut self) -> ModeSpeedW<Csi2VcCtrl2Spec> {
        ModeSpeedW::new(self, 9)
    }
    #[doc = "Bits 10:11 - 11:10\\]
Defines the size of the OCP data bus"]
    #[inline(always)]
    #[must_use]
    pub fn ocp_data_bus_width(&mut self) -> OcpDataBusWidthW<Csi2VcCtrl2Spec> {
        OcpDataBusWidthW::new(self, 10)
    }
    #[doc = "Bit 12 - 12:12\\]
Byte order for RBG565"]
    #[inline(always)]
    #[must_use]
    pub fn rgb565_order(&mut self) -> Rgb565OrderW<Csi2VcCtrl2Spec> {
        Rgb565OrderW::new(self, 12)
    }
    #[doc = "Bit 13 - 13:13\\]
Selection between video port 1 and video port 2. If CSI2_GNQ.NB_VIDEO_PORTS=0, the bit-field is ignored since only video port 1 is present."]
    #[inline(always)]
    #[must_use]
    pub fn vp_source(&mut self) -> VpSourceW<Csi2VcCtrl2Spec> {
        VpSourceW::new(self, 13)
    }
    #[doc = "Bit 14 - 14:14\\]
Ping-pong buffer busy status."]
    #[inline(always)]
    #[must_use]
    pub fn pp_busy(&mut self) -> PpBusyW<Csi2VcCtrl2Spec> {
        PpBusyW::new(self, 14)
    }
    #[doc = "Bit 15 - 15:15\\]
Indicates if previously scheduled activities (packets, BTA) are still being processed. Forced to 1 if VC is enabled. Software should check this bit is 0 before changing channel configuration."]
    #[inline(always)]
    #[must_use]
    pub fn vc_busy(&mut self) -> VcBusyW<Csi2VcCtrl2Spec> {
        VcBusyW::new(self, 15)
    }
    #[doc = "Bit 16 - 16:16\\]
FIFO status"]
    #[inline(always)]
    #[must_use]
    pub fn tx_fifo_full(&mut self) -> TxFifoFullW<Csi2VcCtrl2Spec> {
        TxFifoFullW::new(self, 16)
    }
    #[doc = "Bits 17:19 - 19:17\\]
Defines the threshold value for the DMA request (associated to the TX FIFO)"]
    #[inline(always)]
    #[must_use]
    pub fn dma_tx_threshold(&mut self) -> DmaTxThresholdW<Csi2VcCtrl2Spec> {
        DmaTxThresholdW::new(self, 17)
    }
    #[doc = "Bit 20 - 20:20\\]
FIFO status"]
    #[inline(always)]
    #[must_use]
    pub fn rx_fifo_not_empty(&mut self) -> RxFifoNotEmptyW<Csi2VcCtrl2Spec> {
        RxFifoNotEmptyW::new(self, 20)
    }
    #[doc = "Bits 21:23 - 23:21\\]
Selection of the use of the DMA request (associated to the TX FIFO)"]
    #[inline(always)]
    #[must_use]
    pub fn dma_tx_req_nb(&mut self) -> DmaTxReqNbW<Csi2VcCtrl2Spec> {
        DmaTxReqNbW::new(self, 21)
    }
    #[doc = "Bits 24:26 - 26:24\\]
Defines the threshold value for the DMA request (associated to the RX FIFO)"]
    #[inline(always)]
    #[must_use]
    pub fn dma_rx_threshold(&mut self) -> DmaRxThresholdW<Csi2VcCtrl2Spec> {
        DmaRxThresholdW::new(self, 24)
    }
    #[doc = "Bits 27:29 - 29:27\\]
Selection of the use of the DMA request (associated to the RX FIFO)"]
    #[inline(always)]
    #[must_use]
    pub fn dma_rx_req_nb(&mut self) -> DmaRxReqNbW<Csi2VcCtrl2Spec> {
        DmaRxReqNbW::new(self, 27)
    }
    #[doc = "Bit 30 - 30:30\\]
Enables automatic insertion of DCS command codes when data is sourced by the video port."]
    #[inline(always)]
    #[must_use]
    pub fn dcs_cmd_enable(&mut self) -> DcsCmdEnableW<Csi2VcCtrl2Spec> {
        DcsCmdEnableW::new(self, 30)
    }
    #[doc = "Bit 31 - 31:31\\]
DCS command code value to insert between header and video port or OCP slave data when enabled by DCS_CMD_ENABLE (only when TE mechanism is not used otherwise the bit-field DCS_CMD_CODE is ignored by CSI2 protocol engine)."]
    #[inline(always)]
    #[must_use]
    pub fn dcs_cmd_code(&mut self) -> DcsCmdCodeW<Csi2VcCtrl2Spec> {
        DcsCmdCodeW::new(self, 31)
    }
}
#[doc = "CONTROL REGISTER - Virtual channel This register controls the virtual channel.\n\nYou can [`read`](crate::Reg::read) this register and get [`csi2_vc_ctrl_2::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`csi2_vc_ctrl_2::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct Csi2VcCtrl2Spec;
impl crate::RegisterSpec for Csi2VcCtrl2Spec {
    type Ux = u32;
}
#[doc = "`read()` method returns [`csi2_vc_ctrl_2::R`](R) reader structure"]
impl crate::Readable for Csi2VcCtrl2Spec {}
#[doc = "`write(|w| ..)` method takes [`csi2_vc_ctrl_2::W`](W) writer structure"]
impl crate::Writable for Csi2VcCtrl2Spec {
    type Safety = crate::Unsafe;
    const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
    const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
}
#[doc = "`reset()` method sets CSI2_VC_CTRL_2 to value 0"]
impl crate::Resettable for Csi2VcCtrl2Spec {
    const RESET_VALUE: u32 = 0;
}
