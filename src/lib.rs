#![doc = "Peripheral access API for AWR2544 microcontrollers (generated using svd2rust v0.33.4 ( ))\n\nYou can find an overview of the generated API [here].\n\nAPI features to be included in the [next]
svd2rust release can be generated by cloning the svd2rust [repository], checking out the above commit, and running `cargo doc --open`.\n\n[here]: https://docs.rs/svd2rust/0.33.4/svd2rust/#peripheral-api\n[next]: https://github.com/rust-embedded/svd2rust/blob/master/CHANGELOG.md#unreleased\n[repository]: https://github.com/rust-embedded/svd2rust"]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![no_std]
use core::marker::PhantomData;
use core::ops::Deref;
#[doc = r"Number available in the NVIC for configuring priority"]
pub const NVIC_PRIO_BITS: u8 = 3;
#[allow(unused_imports)]
use generic::*;
#[doc = r"Common register and bit access and modify traits"]
pub mod generic;
#[doc = "MSS_VIM"]
pub struct MssVimR5a {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for MssVimR5a {}
impl MssVimR5a {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const mss_vim_r5a::RegisterBlock = 0x0208_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const mss_vim_r5a::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for MssVimR5a {
    type Target = mss_vim_r5a::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for MssVimR5a {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("MssVimR5a").finish()
    }
}
#[doc = "MSS_VIM"]
pub mod mss_vim_r5a;
#[doc = "MSS_IOMUX"]
pub struct MssIomux {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for MssIomux {}
impl MssIomux {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const mss_iomux::RegisterBlock = 0x020c_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const mss_iomux::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for MssIomux {
    type Target = mss_iomux::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for MssIomux {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("MssIomux").finish()
    }
}
#[doc = "MSS_IOMUX"]
pub mod mss_iomux;
#[doc = "MSS_RCM"]
pub struct MssRcm {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for MssRcm {}
impl MssRcm {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const mss_rcm::RegisterBlock = 0x0210_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const mss_rcm::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for MssRcm {
    type Target = mss_rcm::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for MssRcm {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("MssRcm").finish()
    }
}
#[doc = "MSS_RCM"]
pub mod mss_rcm;
#[doc = "MSS_CTRL"]
pub struct MssCtrl {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for MssCtrl {}
impl MssCtrl {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const mss_ctrl::RegisterBlock = 0x0212_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const mss_ctrl::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for MssCtrl {
    type Target = mss_ctrl::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for MssCtrl {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("MssCtrl").finish()
    }
}
#[doc = "MSS_CTRL"]
pub mod mss_ctrl;
#[doc = "MSS_TOPRCM"]
pub struct MssToprcm {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for MssToprcm {}
impl MssToprcm {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const mss_toprcm::RegisterBlock = 0x0214_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const mss_toprcm::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for MssToprcm {
    type Target = mss_toprcm::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for MssToprcm {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("MssToprcm").finish()
    }
}
#[doc = "MSS_TOPRCM"]
pub mod mss_toprcm;
#[doc = "MSS_PCR1"]
pub struct MssPcr1 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for MssPcr1 {}
impl MssPcr1 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const mss_pcr1::RegisterBlock = 0x02f7_8000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const mss_pcr1::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for MssPcr1 {
    type Target = mss_pcr1::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for MssPcr1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("MssPcr1").finish()
    }
}
#[doc = "MSS_PCR1"]
pub mod mss_pcr1;
#[doc = "PBIST"]
pub struct TopPbist {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for TopPbist {}
impl TopPbist {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const top_pbist::RegisterBlock = 0x02f7_9400 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const top_pbist::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for TopPbist {
    type Target = top_pbist::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for TopPbist {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("TopPbist").finish()
    }
}
#[doc = "PBIST"]
pub mod top_pbist;
#[doc = "STC"]
pub struct MssR5ssStc {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for MssR5ssStc {}
impl MssR5ssStc {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const mss_r5ss_stc::RegisterBlock = 0x02f7_9800 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const mss_r5ss_stc::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for MssR5ssStc {
    type Target = mss_r5ss_stc::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for MssR5ssStc {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("MssR5ssStc").finish()
    }
}
#[doc = "STC"]
pub mod mss_r5ss_stc;
#[doc = "MSS_DCC"]
pub struct MssDcca {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for MssDcca {}
impl MssDcca {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const mss_dcca::RegisterBlock = 0x02f7_9c00 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const mss_dcca::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for MssDcca {
    type Target = mss_dcca::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for MssDcca {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("MssDcca").finish()
    }
}
#[doc = "MSS_DCC"]
pub mod mss_dcca;
#[doc = "MSS_DCC"]
pub struct MssDccb {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for MssDccb {}
impl MssDccb {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const mss_dccb::RegisterBlock = 0x02f7_9d00 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const mss_dccb::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for MssDccb {
    type Target = mss_dccb::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for MssDccb {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("MssDccb").finish()
    }
}
#[doc = "MSS_DCC"]
pub mod mss_dccb;
#[doc = "MSS_DCC"]
pub struct MssDccc {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for MssDccc {}
impl MssDccc {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const mss_dccc::RegisterBlock = 0x02f7_9e00 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const mss_dccc::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for MssDccc {
    type Target = mss_dccc::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for MssDccc {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("MssDccc").finish()
    }
}
#[doc = "MSS_DCC"]
pub mod mss_dccc;
#[doc = "MSS_DCC"]
pub struct MssDccd {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for MssDccd {}
impl MssDccd {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const mss_dccd::RegisterBlock = 0x02f7_9f00 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const mss_dccd::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for MssDccd {
    type Target = mss_dccd::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for MssDccd {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("MssDccd").finish()
    }
}
#[doc = "MSS_DCC"]
pub mod mss_dccd;
#[doc = "MSS_RTI"]
pub struct MssRtia {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for MssRtia {}
impl MssRtia {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const mss_rtia::RegisterBlock = 0x02f7_a000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const mss_rtia::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for MssRtia {
    type Target = mss_rtia::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for MssRtia {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("MssRtia").finish()
    }
}
#[doc = "MSS_RTI"]
pub mod mss_rtia;
#[doc = "MSS_RTI"]
pub struct MssRtib {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for MssRtib {}
impl MssRtib {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const mss_rtib::RegisterBlock = 0x02f7_a100 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const mss_rtib::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for MssRtib {
    type Target = mss_rtib::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for MssRtib {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("MssRtib").finish()
    }
}
#[doc = "MSS_RTI"]
pub mod mss_rtib;
#[doc = "MSS_RTI"]
pub struct MssRtic {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for MssRtic {}
impl MssRtic {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const mss_rtic::RegisterBlock = 0x02f7_a200 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const mss_rtic::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for MssRtic {
    type Target = mss_rtic::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for MssRtic {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("MssRtic").finish()
    }
}
#[doc = "MSS_RTI"]
pub mod mss_rtic;
#[doc = "MSS_RTI"]
pub struct MssWdt {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for MssWdt {}
impl MssWdt {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const mss_wdt::RegisterBlock = 0x02f7_a300 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const mss_wdt::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for MssWdt {
    type Target = mss_wdt::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for MssWdt {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("MssWdt").finish()
    }
}
#[doc = "MSS_RTI"]
pub mod mss_wdt;
#[doc = "MSS_ESM"]
pub struct MssEsm {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for MssEsm {}
impl MssEsm {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const mss_esm::RegisterBlock = 0x02f7_a400 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const mss_esm::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for MssEsm {
    type Target = mss_esm::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for MssEsm {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("MssEsm").finish()
    }
}
#[doc = "MSS_ESM"]
pub mod mss_esm;
#[doc = "MSS_CCMR"]
pub struct MssCcmr {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for MssCcmr {}
impl MssCcmr {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const mss_ccmr::RegisterBlock = 0x02f7_ac00 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const mss_ccmr::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for MssCcmr {
    type Target = mss_ccmr::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for MssCcmr {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("MssCcmr").finish()
    }
}
#[doc = "MSS_CCMR"]
pub mod mss_ccmr;
#[doc = "MSS_I2C"]
pub struct MssI2c {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for MssI2c {}
impl MssI2c {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const mss_i2c::RegisterBlock = 0x02f7_b000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const mss_i2c::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for MssI2c {
    type Target = mss_i2c::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for MssI2c {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("MssI2c").finish()
    }
}
#[doc = "MSS_I2C"]
pub mod mss_i2c;
#[doc = "MSS_GIO"]
pub struct MssGio {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for MssGio {}
impl MssGio {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const mss_gio::RegisterBlock = 0x02f7_b400 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const mss_gio::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for MssGio {
    type Target = mss_gio::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for MssGio {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("MssGio").finish()
    }
}
#[doc = "MSS_GIO"]
pub mod mss_gio;
#[doc = "MSS_ECC_AGG_R5A"]
pub struct MssEccAggR5a {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for MssEccAggR5a {}
impl MssEccAggR5a {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const mss_ecc_agg_r5a::RegisterBlock = 0x02f7_b800 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const mss_ecc_agg_r5a::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for MssEccAggR5a {
    type Target = mss_ecc_agg_r5a::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for MssEccAggR5a {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("MssEccAggR5a").finish()
    }
}
#[doc = "MSS_ECC_AGG_R5A"]
pub mod mss_ecc_agg_r5a;
#[doc = "MSS_ECC_AGG_MSS"]
pub struct MssEccAggMss {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for MssEccAggMss {}
impl MssEccAggMss {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const mss_ecc_agg_mss::RegisterBlock = 0x02f7_c000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const mss_ecc_agg_mss::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for MssEccAggMss {
    type Target = mss_ecc_agg_mss::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for MssEccAggMss {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("MssEccAggMss").finish()
    }
}
#[doc = "MSS_ECC_AGG_MSS"]
pub mod mss_ecc_agg_mss;
#[doc = "MSS_SPI"]
pub struct MssSpib {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for MssSpib {}
impl MssSpib {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const mss_spib::RegisterBlock = 0x02f7_ea00 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const mss_spib::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for MssSpib {
    type Target = mss_spib::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for MssSpib {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("MssSpib").finish()
    }
}
#[doc = "MSS_SPI"]
pub mod mss_spib;
#[doc = "MSS_SCI"]
pub struct MssScia {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for MssScia {}
impl MssScia {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const mss_scia::RegisterBlock = 0x02f7_ec00 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const mss_scia::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for MssScia {
    type Target = mss_scia::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for MssScia {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("MssScia").finish()
    }
}
#[doc = "MSS_SCI"]
pub mod mss_scia;
#[doc = "MSS_SCI"]
pub struct MssScib {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for MssScib {}
impl MssScib {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const mss_scib::RegisterBlock = 0x02f7_ed00 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const mss_scib::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for MssScib {
    type Target = mss_scib::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for MssScib {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("MssScib").finish()
    }
}
#[doc = "MSS_SCI"]
pub mod mss_scib;
#[doc = "MSS_GPADC_PKT_RAM"]
pub struct MssGpadcPktRam {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for MssGpadcPktRam {}
impl MssGpadcPktRam {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const mss_gpadc_pkt_ram::RegisterBlock = 0x030c_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const mss_gpadc_pkt_ram::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for MssGpadcPktRam {
    type Target = mss_gpadc_pkt_ram::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for MssGpadcPktRam {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("MssGpadcPktRam").finish()
    }
}
#[doc = "MSS_GPADC_PKT_RAM"]
pub mod mss_gpadc_pkt_ram;
#[doc = "TOP_CTRL"]
pub struct TopCtrl {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for TopCtrl {}
impl TopCtrl {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const top_ctrl::RegisterBlock = 0x030e_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const top_ctrl::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for TopCtrl {
    type Target = top_ctrl::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for TopCtrl {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("TopCtrl").finish()
    }
}
#[doc = "TOP_CTRL"]
pub mod top_ctrl;
#[doc = "TPCC"]
pub struct MssTpccA {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for MssTpccA {}
impl MssTpccA {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const mss_tpcc_a::RegisterBlock = 0x0310_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const mss_tpcc_a::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for MssTpccA {
    type Target = mss_tpcc_a::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for MssTpccA {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("MssTpccA").finish()
    }
}
#[doc = "TPCC"]
pub mod mss_tpcc_a;
#[doc = "Register test environment"]
pub struct MssTptcA0 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for MssTptcA0 {}
impl MssTptcA0 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const mss_tptc_a0::RegisterBlock = 0x0314_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const mss_tptc_a0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for MssTptcA0 {
    type Target = mss_tptc_a0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for MssTptcA0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("MssTptcA0").finish()
    }
}
#[doc = "Register test environment"]
pub mod mss_tptc_a0;
#[doc = "Register test environment"]
pub struct MssTptcA1 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for MssTptcA1 {}
impl MssTptcA1 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const mss_tptc_a1::RegisterBlock = 0x0316_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const mss_tptc_a1::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for MssTptcA1 {
    type Target = mss_tptc_a1::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for MssTptcA1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("MssTptcA1").finish()
    }
}
#[doc = "Register test environment"]
pub mod mss_tptc_a1;
#[doc = "MSS_PCR2"]
pub struct MssPcr2 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for MssPcr2 {}
impl MssPcr2 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const mss_pcr2::RegisterBlock = 0x03f7_8000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const mss_pcr2::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for MssPcr2 {
    type Target = mss_pcr2::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for MssPcr2 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("MssPcr2").finish()
    }
}
#[doc = "MSS_PCR2"]
pub mod mss_pcr2;
#[doc = "MSS_ETPWM"]
pub struct MssEtpwma {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for MssEtpwma {}
impl MssEtpwma {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const mss_etpwma::RegisterBlock = 0x03f7_8c00 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const mss_etpwma::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for MssEtpwma {
    type Target = mss_etpwma::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for MssEtpwma {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("MssEtpwma").finish()
    }
}
#[doc = "MSS_ETPWM"]
pub mod mss_etpwma;
#[doc = "MSS_ETPWM"]
pub struct MssEtpwmb {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for MssEtpwmb {}
impl MssEtpwmb {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const mss_etpwmb::RegisterBlock = 0x03f7_8d00 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const mss_etpwmb::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for MssEtpwmb {
    type Target = mss_etpwmb::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for MssEtpwmb {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("MssEtpwmb").finish()
    }
}
#[doc = "MSS_ETPWM"]
pub mod mss_etpwmb;
#[doc = "MSS_ETPWM"]
pub struct MssEtpwmc {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for MssEtpwmc {}
impl MssEtpwmc {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const mss_etpwmc::RegisterBlock = 0x03f7_8e00 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const mss_etpwmc::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for MssEtpwmc {
    type Target = mss_etpwmc::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for MssEtpwmc {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("MssEtpwmc").finish()
    }
}
#[doc = "MSS_ETPWM"]
pub mod mss_etpwmc;
#[doc = "RSS_RCM"]
pub struct RssRcm {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for RssRcm {}
impl RssRcm {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const rss_rcm::RegisterBlock = 0x0500_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const rss_rcm::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for RssRcm {
    type Target = rss_rcm::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for RssRcm {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("RssRcm").finish()
    }
}
#[doc = "RSS_RCM"]
pub mod rss_rcm;
#[doc = "RSS_CTRL"]
pub struct RssCtrl {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for RssCtrl {}
impl RssCtrl {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const rss_ctrl::RegisterBlock = 0x0502_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const rss_ctrl::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for RssCtrl {
    type Target = rss_ctrl::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for RssCtrl {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("RssCtrl").finish()
    }
}
#[doc = "RSS_CTRL"]
pub mod rss_ctrl;
#[doc = "TPCC"]
pub struct RssTpccA {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for RssTpccA {}
impl RssTpccA {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const rss_tpcc_a::RegisterBlock = 0x0510_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const rss_tpcc_a::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for RssTpccA {
    type Target = rss_tpcc_a::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for RssTpccA {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("RssTpccA").finish()
    }
}
#[doc = "TPCC"]
pub mod rss_tpcc_a;
#[doc = "Register test environment"]
pub struct RssTptcA0 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for RssTptcA0 {}
impl RssTptcA0 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const rss_tptc_a0::RegisterBlock = 0x0516_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const rss_tptc_a0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for RssTptcA0 {
    type Target = rss_tptc_a0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for RssTptcA0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("RssTptcA0").finish()
    }
}
#[doc = "Register test environment"]
pub mod rss_tptc_a0;
#[doc = "DSS_RCM"]
pub struct DssRcm {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for DssRcm {}
impl DssRcm {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const dss_rcm::RegisterBlock = 0x0600_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const dss_rcm::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for DssRcm {
    type Target = dss_rcm::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for DssRcm {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("DssRcm").finish()
    }
}
#[doc = "DSS_RCM"]
pub mod dss_rcm;
#[doc = "DSS_CTRL"]
pub struct DssCtrl {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for DssCtrl {}
impl DssCtrl {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const dss_ctrl::RegisterBlock = 0x0602_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const dss_ctrl::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for DssCtrl {
    type Target = dss_ctrl::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for DssCtrl {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("DssCtrl").finish()
    }
}
#[doc = "DSS_CTRL"]
pub mod dss_ctrl;
#[doc = "DSS_CBUFF"]
pub struct DssCbuff {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for DssCbuff {}
impl DssCbuff {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const dss_cbuff::RegisterBlock = 0x0604_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const dss_cbuff::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for DssCbuff {
    type Target = dss_cbuff::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for DssCbuff {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("DssCbuff").finish()
    }
}
#[doc = "DSS_CBUFF"]
pub mod dss_cbuff;
#[doc = "DSS_HWA_CFG"]
pub struct DssHwaCfg {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for DssHwaCfg {}
impl DssHwaCfg {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const dss_hwa_cfg::RegisterBlock = 0x0606_2000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const dss_hwa_cfg::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for DssHwaCfg {
    type Target = dss_hwa_cfg::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for DssHwaCfg {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("DssHwaCfg").finish()
    }
}
#[doc = "DSS_HWA_CFG"]
pub mod dss_hwa_cfg;
#[doc = "DSS_ECC_AGG"]
pub struct DssEccAgg {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for DssEccAgg {}
impl DssEccAgg {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const dss_ecc_agg::RegisterBlock = 0x060a_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const dss_ecc_agg::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for DssEccAgg {
    type Target = dss_ecc_agg::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for DssEccAgg {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("DssEccAgg").finish()
    }
}
#[doc = "DSS_ECC_AGG"]
pub mod dss_ecc_agg;
#[doc = "TPCC"]
pub struct DssTpccA {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for DssTpccA {}
impl DssTpccA {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const dss_tpcc_a::RegisterBlock = 0x0610_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const dss_tpcc_a::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for DssTpccA {
    type Target = dss_tpcc_a::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for DssTpccA {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("DssTpccA").finish()
    }
}
#[doc = "TPCC"]
pub mod dss_tpcc_a;
#[doc = "Register test environment"]
pub struct DssTptcA0 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for DssTptcA0 {}
impl DssTptcA0 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const dss_tptc_a0::RegisterBlock = 0x0616_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const dss_tptc_a0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for DssTptcA0 {
    type Target = dss_tptc_a0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for DssTptcA0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("DssTptcA0").finish()
    }
}
#[doc = "Register test environment"]
pub mod dss_tptc_a0;
#[doc = "Register test environment"]
pub struct DssTptcA1 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for DssTptcA1 {}
impl DssTptcA1 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const dss_tptc_a1::RegisterBlock = 0x0618_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const dss_tptc_a1::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for DssTptcA1 {
    type Target = dss_tptc_a1::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for DssTptcA1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("DssTptcA1").finish()
    }
}
#[doc = "Register test environment"]
pub mod dss_tptc_a1;
#[doc = "CSI2 protocol engine (MIPI Display Serial Interface Protocole)"]
pub struct DssCsi2ProtocolEngine {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for DssCsi2ProtocolEngine {}
impl DssCsi2ProtocolEngine {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const dss_csi2_protocol_engine::RegisterBlock = 0x0630_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const dss_csi2_protocol_engine::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for DssCsi2ProtocolEngine {
    type Target = dss_csi2_protocol_engine::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for DssCsi2ProtocolEngine {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("DssCsi2ProtocolEngine").finish()
    }
}
#[doc = "CSI2 protocol engine (MIPI Display Serial Interface Protocole)"]
pub mod dss_csi2_protocol_engine;
#[doc = "CSI2_PHY"]
pub struct DssCsi2Phy {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for DssCsi2Phy {}
impl DssCsi2Phy {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const dss_csi2_phy::RegisterBlock = 0x0630_0200 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const dss_csi2_phy::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for DssCsi2Phy {
    type Target = dss_csi2_phy::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for DssCsi2Phy {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("DssCsi2Phy").finish()
    }
}
#[doc = "CSI2_PHY"]
pub mod dss_csi2_phy;
#[doc = "DSS_PCR"]
pub struct DssPcr {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for DssPcr {}
impl DssPcr {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const dss_pcr::RegisterBlock = 0x06f7_8000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const dss_pcr::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for DssPcr {
    type Target = dss_pcr::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for DssPcr {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("DssPcr").finish()
    }
}
#[doc = "DSS_PCR"]
pub mod dss_pcr;
#[doc = "PBIST"]
pub struct DssDspPbist {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for DssDspPbist {}
impl DssDspPbist {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const dss_dsp_pbist::RegisterBlock = 0x06f7_9000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const dss_dsp_pbist::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for DssDspPbist {
    type Target = dss_dsp_pbist::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for DssDspPbist {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("DssDspPbist").finish()
    }
}
#[doc = "PBIST"]
pub mod dss_dsp_pbist;
#[doc = "MSS_ESM"]
pub struct DssEsm {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for DssEsm {}
impl DssEsm {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const dss_esm::RegisterBlock = 0x06f7_d000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const dss_esm::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for DssEsm {
    type Target = dss_esm::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for DssEsm {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("DssEsm").finish()
    }
}
#[doc = "MSS_ESM"]
pub mod dss_esm;
#[doc = "MSS_CPSW"]
pub struct MssCpsw {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for MssCpsw {}
impl MssCpsw {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const mss_cpsw::RegisterBlock = 0x0700_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const mss_cpsw::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for MssCpsw {
    type Target = mss_cpsw::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for MssCpsw {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("MssCpsw").finish()
    }
}
#[doc = "MSS_CPSW"]
pub mod mss_cpsw;
#[doc = "MPU"]
pub struct MpuMssL2Banka {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for MpuMssL2Banka {}
impl MpuMssL2Banka {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const mpu_mss_l2_banka::RegisterBlock = 0x4002_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const mpu_mss_l2_banka::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for MpuMssL2Banka {
    type Target = mpu_mss_l2_banka::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for MpuMssL2Banka {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("MpuMssL2Banka").finish()
    }
}
#[doc = "MPU"]
pub mod mpu_mss_l2_banka;
#[doc = "MPU"]
pub struct MpuMssL2Bankb {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for MpuMssL2Bankb {}
impl MpuMssL2Bankb {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const mpu_mss_l2_bankb::RegisterBlock = 0x4004_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const mpu_mss_l2_bankb::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for MpuMssL2Bankb {
    type Target = mpu_mss_l2_bankb::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for MpuMssL2Bankb {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("MpuMssL2Bankb").finish()
    }
}
#[doc = "MPU"]
pub mod mpu_mss_l2_bankb;
#[doc = "MPU"]
pub struct MpuMssMbox {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for MpuMssMbox {}
impl MpuMssMbox {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const mpu_mss_mbox::RegisterBlock = 0x4008_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const mpu_mss_mbox::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for MpuMssMbox {
    type Target = mpu_mss_mbox::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for MpuMssMbox {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("MpuMssMbox").finish()
    }
}
#[doc = "MPU"]
pub mod mpu_mss_mbox;
#[doc = "MPU"]
pub struct MpuMssPcra {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for MpuMssPcra {}
impl MpuMssPcra {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const mpu_mss_pcra::RegisterBlock = 0x400a_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const mpu_mss_pcra::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for MpuMssPcra {
    type Target = mpu_mss_pcra::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for MpuMssPcra {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("MpuMssPcra").finish()
    }
}
#[doc = "MPU"]
pub mod mpu_mss_pcra;
#[doc = "MPU"]
pub struct MpuMssQspi {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for MpuMssQspi {}
impl MpuMssQspi {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const mpu_mss_qspi::RegisterBlock = 0x400c_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const mpu_mss_qspi::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for MpuMssQspi {
    type Target = mpu_mss_qspi::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for MpuMssQspi {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("MpuMssQspi").finish()
    }
}
#[doc = "MPU"]
pub mod mpu_mss_qspi;
#[doc = "MPU"]
pub struct MpuMssCr5aAxis {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for MpuMssCr5aAxis {}
impl MpuMssCr5aAxis {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const mpu_mss_cr5a_axis::RegisterBlock = 0x400e_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const mpu_mss_cr5a_axis::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for MpuMssCr5aAxis {
    type Target = mpu_mss_cr5a_axis::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for MpuMssCr5aAxis {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("MpuMssCr5aAxis").finish()
    }
}
#[doc = "MPU"]
pub mod mpu_mss_cr5a_axis;
#[doc = "MPU"]
pub struct MpuDssL2Bankc {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for MpuDssL2Bankc {}
impl MpuDssL2Bankc {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const mpu_dss_l2_bankc::RegisterBlock = 0x4010_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const mpu_dss_l2_bankc::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for MpuDssL2Bankc {
    type Target = mpu_dss_l2_bankc::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for MpuDssL2Bankc {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("MpuDssL2Bankc").finish()
    }
}
#[doc = "MPU"]
pub mod mpu_dss_l2_bankc;
#[doc = "MPU"]
pub struct MpuDssL3Banka {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for MpuDssL3Banka {}
impl MpuDssL3Banka {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const mpu_dss_l3_banka::RegisterBlock = 0x4012_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const mpu_dss_l3_banka::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for MpuDssL3Banka {
    type Target = mpu_dss_l3_banka::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for MpuDssL3Banka {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("MpuDssL3Banka").finish()
    }
}
#[doc = "MPU"]
pub mod mpu_dss_l3_banka;
#[doc = "MPU"]
pub struct MpuDssL3Bankb {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for MpuDssL3Bankb {}
impl MpuDssL3Bankb {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const mpu_dss_l3_bankb::RegisterBlock = 0x4014_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const mpu_dss_l3_bankb::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for MpuDssL3Bankb {
    type Target = mpu_dss_l3_bankb::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for MpuDssL3Bankb {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("MpuDssL3Bankb").finish()
    }
}
#[doc = "MPU"]
pub mod mpu_dss_l3_bankb;
#[doc = "MSS_MCRC"]
pub struct DssMcrc {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for DssMcrc {}
impl DssMcrc {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const dss_mcrc::RegisterBlock = 0x8330_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const dss_mcrc::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for DssMcrc {
    type Target = dss_mcrc::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for DssMcrc {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("DssMcrc").finish()
    }
}
#[doc = "MSS_MCRC"]
pub mod dss_mcrc;
#[doc = "MSS_MCRC"]
pub struct MssMcrc {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for MssMcrc {}
impl MssMcrc {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const mss_mcrc::RegisterBlock = 0xc502_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const mss_mcrc::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for MssMcrc {
    type Target = mss_mcrc::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for MssMcrc {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("MssMcrc").finish()
    }
}
#[doc = "MSS_MCRC"]
pub mod mss_mcrc;
#[doc = "MSS_GPADC_DATA_RAM"]
pub struct MssGpadcDataRam {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for MssGpadcDataRam {}
impl MssGpadcDataRam {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const mss_gpadc_data_ram::RegisterBlock = 0xc503_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const mss_gpadc_data_ram::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for MssGpadcDataRam {
    type Target = mss_gpadc_data_ram::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for MssGpadcDataRam {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("MssGpadcDataRam").finish()
    }
}
#[doc = "MSS_GPADC_DATA_RAM"]
pub mod mss_gpadc_data_ram;
#[doc = "MSS_QSPI"]
pub struct MssQspi {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for MssQspi {}
impl MssQspi {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const mss_qspi::RegisterBlock = 0xc800_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const mss_qspi::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for MssQspi {
    type Target = mss_qspi::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for MssQspi {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("MssQspi").finish()
    }
}
#[doc = "MSS_QSPI"]
pub mod mss_qspi;
#[no_mangle]
static mut DEVICE_PERIPHERALS: bool = false;
#[doc = r" All the peripherals."]
#[allow(non_snake_case)]
pub struct Peripherals {
    #[doc = "MSS_VIM_R5A"]
    pub mss_vim_r5a: MssVimR5a,
    #[doc = "MSS_IOMUX"]
    pub mss_iomux: MssIomux,
    #[doc = "MSS_RCM"]
    pub mss_rcm: MssRcm,
    #[doc = "MSS_CTRL"]
    pub mss_ctrl: MssCtrl,
    #[doc = "MSS_TOPRCM"]
    pub mss_toprcm: MssToprcm,
    #[doc = "MSS_PCR1"]
    pub mss_pcr1: MssPcr1,
    #[doc = "TOP_PBIST"]
    pub top_pbist: TopPbist,
    #[doc = "MSS_R5SS_STC"]
    pub mss_r5ss_stc: MssR5ssStc,
    #[doc = "MSS_DCCA"]
    pub mss_dcca: MssDcca,
    #[doc = "MSS_DCCB"]
    pub mss_dccb: MssDccb,
    #[doc = "MSS_DCCC"]
    pub mss_dccc: MssDccc,
    #[doc = "MSS_DCCD"]
    pub mss_dccd: MssDccd,
    #[doc = "MSS_RTIA"]
    pub mss_rtia: MssRtia,
    #[doc = "MSS_RTIB"]
    pub mss_rtib: MssRtib,
    #[doc = "MSS_RTIC"]
    pub mss_rtic: MssRtic,
    #[doc = "MSS_WDT"]
    pub mss_wdt: MssWdt,
    #[doc = "MSS_ESM"]
    pub mss_esm: MssEsm,
    #[doc = "MSS_CCMR"]
    pub mss_ccmr: MssCcmr,
    #[doc = "MSS_I2C"]
    pub mss_i2c: MssI2c,
    #[doc = "MSS_GIO"]
    pub mss_gio: MssGio,
    #[doc = "MSS_ECC_AGG_R5A"]
    pub mss_ecc_agg_r5a: MssEccAggR5a,
    #[doc = "MSS_ECC_AGG_MSS"]
    pub mss_ecc_agg_mss: MssEccAggMss,
    #[doc = "MSS_SPIB"]
    pub mss_spib: MssSpib,
    #[doc = "MSS_SCIA"]
    pub mss_scia: MssScia,
    #[doc = "MSS_SCIB"]
    pub mss_scib: MssScib,
    #[doc = "MSS_GPADC_PKT_RAM"]
    pub mss_gpadc_pkt_ram: MssGpadcPktRam,
    #[doc = "TOP_CTRL"]
    pub top_ctrl: TopCtrl,
    #[doc = "MSS_TPCC_A"]
    pub mss_tpcc_a: MssTpccA,
    #[doc = "MSS_TPTC_A0"]
    pub mss_tptc_a0: MssTptcA0,
    #[doc = "MSS_TPTC_A1"]
    pub mss_tptc_a1: MssTptcA1,
    #[doc = "MSS_PCR2"]
    pub mss_pcr2: MssPcr2,
    #[doc = "MSS_ETPWMA"]
    pub mss_etpwma: MssEtpwma,
    #[doc = "MSS_ETPWMB"]
    pub mss_etpwmb: MssEtpwmb,
    #[doc = "MSS_ETPWMC"]
    pub mss_etpwmc: MssEtpwmc,
    #[doc = "RSS_RCM"]
    pub rss_rcm: RssRcm,
    #[doc = "RSS_CTRL"]
    pub rss_ctrl: RssCtrl,
    #[doc = "RSS_TPCC_A"]
    pub rss_tpcc_a: RssTpccA,
    #[doc = "RSS_TPTC_A0"]
    pub rss_tptc_a0: RssTptcA0,
    #[doc = "DSS_RCM"]
    pub dss_rcm: DssRcm,
    #[doc = "DSS_CTRL"]
    pub dss_ctrl: DssCtrl,
    #[doc = "DSS_CBUFF"]
    pub dss_cbuff: DssCbuff,
    #[doc = "DSS_HWA_CFG"]
    pub dss_hwa_cfg: DssHwaCfg,
    #[doc = "DSS_ECC_AGG"]
    pub dss_ecc_agg: DssEccAgg,
    #[doc = "DSS_TPCC_A"]
    pub dss_tpcc_a: DssTpccA,
    #[doc = "DSS_TPTC_A0"]
    pub dss_tptc_a0: DssTptcA0,
    #[doc = "DSS_TPTC_A1"]
    pub dss_tptc_a1: DssTptcA1,
    #[doc = "DSS_CSI2_PROTOCOL_ENGINE"]
    pub dss_csi2_protocol_engine: DssCsi2ProtocolEngine,
    #[doc = "DSS_CSI2_PHY"]
    pub dss_csi2_phy: DssCsi2Phy,
    #[doc = "DSS_PCR"]
    pub dss_pcr: DssPcr,
    #[doc = "DSS_DSP_PBIST"]
    pub dss_dsp_pbist: DssDspPbist,
    #[doc = "DSS_ESM"]
    pub dss_esm: DssEsm,
    #[doc = "MSS_CPSW"]
    pub mss_cpsw: MssCpsw,
    #[doc = "MPU_MSS_L2_BANKA"]
    pub mpu_mss_l2_banka: MpuMssL2Banka,
    #[doc = "MPU_MSS_L2_BANKB"]
    pub mpu_mss_l2_bankb: MpuMssL2Bankb,
    #[doc = "MPU_MSS_MBOX"]
    pub mpu_mss_mbox: MpuMssMbox,
    #[doc = "MPU_MSS_PCRA"]
    pub mpu_mss_pcra: MpuMssPcra,
    #[doc = "MPU_MSS_QSPI"]
    pub mpu_mss_qspi: MpuMssQspi,
    #[doc = "MPU_MSS_CR5A_AXIS"]
    pub mpu_mss_cr5a_axis: MpuMssCr5aAxis,
    #[doc = "MPU_DSS_L2_BANKC"]
    pub mpu_dss_l2_bankc: MpuDssL2Bankc,
    #[doc = "MPU_DSS_L3_BANKA"]
    pub mpu_dss_l3_banka: MpuDssL3Banka,
    #[doc = "MPU_DSS_L3_BANKB"]
    pub mpu_dss_l3_bankb: MpuDssL3Bankb,
    #[doc = "DSS_MCRC"]
    pub dss_mcrc: DssMcrc,
    #[doc = "MSS_MCRC"]
    pub mss_mcrc: MssMcrc,
    #[doc = "MSS_GPADC_DATA_RAM"]
    pub mss_gpadc_data_ram: MssGpadcDataRam,
    #[doc = "MSS_QSPI"]
    pub mss_qspi: MssQspi,
}
impl Peripherals {
    #[doc = r" Returns all the peripherals *once*."]
    #[cfg(feature = "critical-section")]
    #[inline]
    pub fn take() -> Option<Self> {
        critical_section::with(|_| {
            if unsafe { DEVICE_PERIPHERALS } {
                return None;
            }
            Some(unsafe { Peripherals::steal() })
        })
    }
    #[doc = r" Unchecked version of `Peripherals::take`."]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Each of the returned peripherals must be used at most once."]
    #[inline]
    pub unsafe fn steal() -> Self {
        DEVICE_PERIPHERALS = true;
        Peripherals {
            mss_vim_r5a: MssVimR5a::steal(),
            mss_iomux: MssIomux::steal(),
            mss_rcm: MssRcm::steal(),
            mss_ctrl: MssCtrl::steal(),
            mss_toprcm: MssToprcm::steal(),
            mss_pcr1: MssPcr1::steal(),
            top_pbist: TopPbist::steal(),
            mss_r5ss_stc: MssR5ssStc::steal(),
            mss_dcca: MssDcca::steal(),
            mss_dccb: MssDccb::steal(),
            mss_dccc: MssDccc::steal(),
            mss_dccd: MssDccd::steal(),
            mss_rtia: MssRtia::steal(),
            mss_rtib: MssRtib::steal(),
            mss_rtic: MssRtic::steal(),
            mss_wdt: MssWdt::steal(),
            mss_esm: MssEsm::steal(),
            mss_ccmr: MssCcmr::steal(),
            mss_i2c: MssI2c::steal(),
            mss_gio: MssGio::steal(),
            mss_ecc_agg_r5a: MssEccAggR5a::steal(),
            mss_ecc_agg_mss: MssEccAggMss::steal(),
            mss_spib: MssSpib::steal(),
            mss_scia: MssScia::steal(),
            mss_scib: MssScib::steal(),
            mss_gpadc_pkt_ram: MssGpadcPktRam::steal(),
            top_ctrl: TopCtrl::steal(),
            mss_tpcc_a: MssTpccA::steal(),
            mss_tptc_a0: MssTptcA0::steal(),
            mss_tptc_a1: MssTptcA1::steal(),
            mss_pcr2: MssPcr2::steal(),
            mss_etpwma: MssEtpwma::steal(),
            mss_etpwmb: MssEtpwmb::steal(),
            mss_etpwmc: MssEtpwmc::steal(),
            rss_rcm: RssRcm::steal(),
            rss_ctrl: RssCtrl::steal(),
            rss_tpcc_a: RssTpccA::steal(),
            rss_tptc_a0: RssTptcA0::steal(),
            dss_rcm: DssRcm::steal(),
            dss_ctrl: DssCtrl::steal(),
            dss_cbuff: DssCbuff::steal(),
            dss_hwa_cfg: DssHwaCfg::steal(),
            dss_ecc_agg: DssEccAgg::steal(),
            dss_tpcc_a: DssTpccA::steal(),
            dss_tptc_a0: DssTptcA0::steal(),
            dss_tptc_a1: DssTptcA1::steal(),
            dss_csi2_protocol_engine: DssCsi2ProtocolEngine::steal(),
            dss_csi2_phy: DssCsi2Phy::steal(),
            dss_pcr: DssPcr::steal(),
            dss_dsp_pbist: DssDspPbist::steal(),
            dss_esm: DssEsm::steal(),
            mss_cpsw: MssCpsw::steal(),
            mpu_mss_l2_banka: MpuMssL2Banka::steal(),
            mpu_mss_l2_bankb: MpuMssL2Bankb::steal(),
            mpu_mss_mbox: MpuMssMbox::steal(),
            mpu_mss_pcra: MpuMssPcra::steal(),
            mpu_mss_qspi: MpuMssQspi::steal(),
            mpu_mss_cr5a_axis: MpuMssCr5aAxis::steal(),
            mpu_dss_l2_bankc: MpuDssL2Bankc::steal(),
            mpu_dss_l3_banka: MpuDssL3Banka::steal(),
            mpu_dss_l3_bankb: MpuDssL3Bankb::steal(),
            dss_mcrc: DssMcrc::steal(),
            mss_mcrc: MssMcrc::steal(),
            mss_gpadc_data_ram: MssGpadcDataRam::steal(),
            mss_qspi: MssQspi::steal(),
        }
    }
}
