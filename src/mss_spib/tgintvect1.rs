#[doc = "Register `TGINTVECT1` reader"]
pub type R = crate::R<Tgintvect1Spec>;
#[doc = "Register `TGINTVECT1` writer"]
pub type W = crate::W<Tgintvect1Spec>;
#[doc = "Field `SUSPEND1` reader - 0:0\\]
ΓÇ£Transfer suspendedΓÇ¥ or ΓÇ£transfer finishedΓÇ¥ interrupt.(MibSPI Only) The SUSPEND1 flag is updated depending on the type of interrupt reflected by the VECTOR value field. 1 =The interrupt type is a ΓÇ£transfer suspendedΓÇ¥ interrupt. I.e. the transfer group referenced by INTVECT1 has asserted an interrupt, because the buffer to be transferred next is in ΓÇ£suspend to waitΓÇ¥ mode. 0 =The interrupt type is a ΓÇ£transfer finishedΓÇ¥ interrupt. I.e. the buffer array referenced by INTVECT1 has asserted an interrupt, because all data from the whole transfer group has been transferred. Note: Special case for SUSPEND interrupt When thereΓÇÖs a ΓÇ£transfer suspendedΓÇ¥ interrupt(SUSPEND1 bit is set to ΓÇÿ1ΓÇÖ), reading the TGINTVECT1 register does not clear the ΓÇ£TG SuspendedΓÇ¥ interrupt. The SUSPEND condition should be resolved first before the interrupt can be cleared. This condition can be cleared by writing a new data to that TXRAM location and/or reading the data from that RXRAM location depending upon the SUSPEND criteria programmed in the ΓÇ£BUFMODEΓÇ¥ field of that TXRAM location. The SUSPEND1 bit always returns value ΓÇÿ0ΓÇÖ in SPI / Compatibility mode MibSPI. Even while there is an RXOVRN or any Error interrupt in Multibuffer mode, SUSPEND1 bit stays ΓÇÿ0ΓÇÖ. Refer to Section 6.2 on page 77 &amp; Section 6.3 on page 77 for more details and notes on better handling of interrupts. Note: Reading Error Vector Reading an Error Vector in the TGINTVECT1 register will NOT clear the Error flags in the SPIFLG register. The Error Flags in SPIFLG need to be write-cleared after servicing them suitably. If ΓÇ£TG CompletedΓÇ¥ interrupt occurs for a TG and after a while ΓÇ£TG SuspendedΓÇ¥ flag too gets set for the same TG, then the TGINTVECT1 register will show ΓÇ£TG CompletedΓÇ¥ interrupt giving it higher priority than the ΓÇ£TG SuspendedΓÇ¥ interrrupt."]
pub type Suspend1R = crate::BitReader;
#[doc = "Field `SUSPEND1` writer - 0:0\\]
ΓÇ£Transfer suspendedΓÇ¥ or ΓÇ£transfer finishedΓÇ¥ interrupt.(MibSPI Only) The SUSPEND1 flag is updated depending on the type of interrupt reflected by the VECTOR value field. 1 =The interrupt type is a ΓÇ£transfer suspendedΓÇ¥ interrupt. I.e. the transfer group referenced by INTVECT1 has asserted an interrupt, because the buffer to be transferred next is in ΓÇ£suspend to waitΓÇ¥ mode. 0 =The interrupt type is a ΓÇ£transfer finishedΓÇ¥ interrupt. I.e. the buffer array referenced by INTVECT1 has asserted an interrupt, because all data from the whole transfer group has been transferred. Note: Special case for SUSPEND interrupt When thereΓÇÖs a ΓÇ£transfer suspendedΓÇ¥ interrupt(SUSPEND1 bit is set to ΓÇÿ1ΓÇÖ), reading the TGINTVECT1 register does not clear the ΓÇ£TG SuspendedΓÇ¥ interrupt. The SUSPEND condition should be resolved first before the interrupt can be cleared. This condition can be cleared by writing a new data to that TXRAM location and/or reading the data from that RXRAM location depending upon the SUSPEND criteria programmed in the ΓÇ£BUFMODEΓÇ¥ field of that TXRAM location. The SUSPEND1 bit always returns value ΓÇÿ0ΓÇÖ in SPI / Compatibility mode MibSPI. Even while there is an RXOVRN or any Error interrupt in Multibuffer mode, SUSPEND1 bit stays ΓÇÿ0ΓÇÖ. Refer to Section 6.2 on page 77 &amp; Section 6.3 on page 77 for more details and notes on better handling of interrupts. Note: Reading Error Vector Reading an Error Vector in the TGINTVECT1 register will NOT clear the Error flags in the SPIFLG register. The Error Flags in SPIFLG need to be write-cleared after servicing them suitably. If ΓÇ£TG CompletedΓÇ¥ interrupt occurs for a TG and after a while ΓÇ£TG SuspendedΓÇ¥ flag too gets set for the same TG, then the TGINTVECT1 register will show ΓÇ£TG CompletedΓÇ¥ interrupt giving it higher priority than the ΓÇ£TG SuspendedΓÇ¥ interrrupt."]
pub type Suspend1W<'a, REG> = crate::BitWriter<'a, REG>;
#[doc = "Field `INTVECT1` reader - 5:1\\]
Interrupt vector for interrupt line INT1. INTVECT1 returns the vector of the pending interrupt at interrupt line INT0. If more than one interrupt is pending, INTVECT1 always references the highest priority interrupt source first. The vectors generated are different for SPI / Compatibility mode of MibSPI and Multibuffer mode of MibSPI. INTVECT1 field just reflects the status of SPIFLG register in a vectorized format. So, any updates to SPIFLG will automatically reflect in the Vector value in this register. SPI / Compatibility mode - MibSPI The interrupts available for SPI / Compatibility mode - MibSPI, in the descending order of their priorities are as given below. Transmission Error Interrupt Receive Buffer Overrun Interrupt Receive Buffer Full Interrupt Transmit Buffer Empty Interrupt Vectors for each of these interrupts will be reflected on the INTVECT1 bits, when they occur. Reading the vectors for the ΓÇ£Receive Buffer OverrunΓÇ¥ &amp; ΓÇ£Receive Buffer FullΓÇ¥ interrupts will automatically clear the respective flags in the SPIFLG register. On reading the INTVECT1 bits, the vector of the next highest priority interrupt (if any) will then be reflected on the INTVECT1 bits. If two or more interrupts occur simultaneously, the vector for the higest priority interrupt will be reflected on the INTVECT1 bits. Reading the Vector register when ΓÇ£Transmitter EmptyΓÇ¥ is indicated does not clear the TXINTFLG in SPIFLG register. Writing a new data to SPIDATx register clears the ΓÇ£Transmitter EmptyΓÇ¥ interrupt. 00000b no interrupt pending 10001b Error interrupt pending. Refer to LS Byte of SPIFLG to determine more details about the type of error. 10011b Pending interrupt is ΓÇ£Receive Buffer Overrun InterruptΓÇ¥ 10010b Pending interrupt is ΓÇ£Receive Buiffer Full InterruptΓÇ¥ 10100b Pending interrupt is ΓÇ£Transmit Buffer Empty InterruptΓÇ¥ All other bit combinations Reserved Note: Exception for clearing of RXINT If both SPIBUF and RXBUF (internal buffer) are full, then, reading TGINTVECT1 register (while it shows 10010) does not clear the RXINTFLG in SPIFLG register. In this case, only way to clear the Interrupt is to read out the SPIBUF again until thereΓÇÖs no more unread RX data."]
pub type Intvect1R = crate::FieldReader;
#[doc = "Field `INTVECT1` writer - 5:1\\]
Interrupt vector for interrupt line INT1. INTVECT1 returns the vector of the pending interrupt at interrupt line INT0. If more than one interrupt is pending, INTVECT1 always references the highest priority interrupt source first. The vectors generated are different for SPI / Compatibility mode of MibSPI and Multibuffer mode of MibSPI. INTVECT1 field just reflects the status of SPIFLG register in a vectorized format. So, any updates to SPIFLG will automatically reflect in the Vector value in this register. SPI / Compatibility mode - MibSPI The interrupts available for SPI / Compatibility mode - MibSPI, in the descending order of their priorities are as given below. Transmission Error Interrupt Receive Buffer Overrun Interrupt Receive Buffer Full Interrupt Transmit Buffer Empty Interrupt Vectors for each of these interrupts will be reflected on the INTVECT1 bits, when they occur. Reading the vectors for the ΓÇ£Receive Buffer OverrunΓÇ¥ &amp; ΓÇ£Receive Buffer FullΓÇ¥ interrupts will automatically clear the respective flags in the SPIFLG register. On reading the INTVECT1 bits, the vector of the next highest priority interrupt (if any) will then be reflected on the INTVECT1 bits. If two or more interrupts occur simultaneously, the vector for the higest priority interrupt will be reflected on the INTVECT1 bits. Reading the Vector register when ΓÇ£Transmitter EmptyΓÇ¥ is indicated does not clear the TXINTFLG in SPIFLG register. Writing a new data to SPIDATx register clears the ΓÇ£Transmitter EmptyΓÇ¥ interrupt. 00000b no interrupt pending 10001b Error interrupt pending. Refer to LS Byte of SPIFLG to determine more details about the type of error. 10011b Pending interrupt is ΓÇ£Receive Buffer Overrun InterruptΓÇ¥ 10010b Pending interrupt is ΓÇ£Receive Buiffer Full InterruptΓÇ¥ 10100b Pending interrupt is ΓÇ£Transmit Buffer Empty InterruptΓÇ¥ All other bit combinations Reserved Note: Exception for clearing of RXINT If both SPIBUF and RXBUF (internal buffer) are full, then, reading TGINTVECT1 register (while it shows 10010) does not clear the RXINTFLG in SPIFLG register. In this case, only way to clear the Interrupt is to read out the SPIBUF again until thereΓÇÖs no more unread RX data."]
pub type Intvect1W<'a, REG> = crate::FieldWriter<'a, REG, 5>;
#[doc = "Field `NU` reader - 31:6\\]
Reserved. Reads return ΓÇÿ0ΓÇÖ and writes have no effect."]
pub type NuR = crate::FieldReader<u32>;
#[doc = "Field `NU` writer - 31:6\\]
Reserved. Reads return ΓÇÿ0ΓÇÖ and writes have no effect."]
pub type NuW<'a, REG> = crate::FieldWriter<'a, REG, 26, u32>;
impl R {
    #[doc = "Bit 0 - 0:0\\]
ΓÇ£Transfer suspendedΓÇ¥ or ΓÇ£transfer finishedΓÇ¥ interrupt.(MibSPI Only) The SUSPEND1 flag is updated depending on the type of interrupt reflected by the VECTOR value field. 1 =The interrupt type is a ΓÇ£transfer suspendedΓÇ¥ interrupt. I.e. the transfer group referenced by INTVECT1 has asserted an interrupt, because the buffer to be transferred next is in ΓÇ£suspend to waitΓÇ¥ mode. 0 =The interrupt type is a ΓÇ£transfer finishedΓÇ¥ interrupt. I.e. the buffer array referenced by INTVECT1 has asserted an interrupt, because all data from the whole transfer group has been transferred. Note: Special case for SUSPEND interrupt When thereΓÇÖs a ΓÇ£transfer suspendedΓÇ¥ interrupt(SUSPEND1 bit is set to ΓÇÿ1ΓÇÖ), reading the TGINTVECT1 register does not clear the ΓÇ£TG SuspendedΓÇ¥ interrupt. The SUSPEND condition should be resolved first before the interrupt can be cleared. This condition can be cleared by writing a new data to that TXRAM location and/or reading the data from that RXRAM location depending upon the SUSPEND criteria programmed in the ΓÇ£BUFMODEΓÇ¥ field of that TXRAM location. The SUSPEND1 bit always returns value ΓÇÿ0ΓÇÖ in SPI / Compatibility mode MibSPI. Even while there is an RXOVRN or any Error interrupt in Multibuffer mode, SUSPEND1 bit stays ΓÇÿ0ΓÇÖ. Refer to Section 6.2 on page 77 &amp; Section 6.3 on page 77 for more details and notes on better handling of interrupts. Note: Reading Error Vector Reading an Error Vector in the TGINTVECT1 register will NOT clear the Error flags in the SPIFLG register. The Error Flags in SPIFLG need to be write-cleared after servicing them suitably. If ΓÇ£TG CompletedΓÇ¥ interrupt occurs for a TG and after a while ΓÇ£TG SuspendedΓÇ¥ flag too gets set for the same TG, then the TGINTVECT1 register will show ΓÇ£TG CompletedΓÇ¥ interrupt giving it higher priority than the ΓÇ£TG SuspendedΓÇ¥ interrrupt."]
    #[inline(always)]
    pub fn suspend1(&self) -> Suspend1R {
        Suspend1R::new((self.bits & 1) != 0)
    }
    #[doc = "Bits 1:5 - 5:1\\]
Interrupt vector for interrupt line INT1. INTVECT1 returns the vector of the pending interrupt at interrupt line INT0. If more than one interrupt is pending, INTVECT1 always references the highest priority interrupt source first. The vectors generated are different for SPI / Compatibility mode of MibSPI and Multibuffer mode of MibSPI. INTVECT1 field just reflects the status of SPIFLG register in a vectorized format. So, any updates to SPIFLG will automatically reflect in the Vector value in this register. SPI / Compatibility mode - MibSPI The interrupts available for SPI / Compatibility mode - MibSPI, in the descending order of their priorities are as given below. Transmission Error Interrupt Receive Buffer Overrun Interrupt Receive Buffer Full Interrupt Transmit Buffer Empty Interrupt Vectors for each of these interrupts will be reflected on the INTVECT1 bits, when they occur. Reading the vectors for the ΓÇ£Receive Buffer OverrunΓÇ¥ &amp; ΓÇ£Receive Buffer FullΓÇ¥ interrupts will automatically clear the respective flags in the SPIFLG register. On reading the INTVECT1 bits, the vector of the next highest priority interrupt (if any) will then be reflected on the INTVECT1 bits. If two or more interrupts occur simultaneously, the vector for the higest priority interrupt will be reflected on the INTVECT1 bits. Reading the Vector register when ΓÇ£Transmitter EmptyΓÇ¥ is indicated does not clear the TXINTFLG in SPIFLG register. Writing a new data to SPIDATx register clears the ΓÇ£Transmitter EmptyΓÇ¥ interrupt. 00000b no interrupt pending 10001b Error interrupt pending. Refer to LS Byte of SPIFLG to determine more details about the type of error. 10011b Pending interrupt is ΓÇ£Receive Buffer Overrun InterruptΓÇ¥ 10010b Pending interrupt is ΓÇ£Receive Buiffer Full InterruptΓÇ¥ 10100b Pending interrupt is ΓÇ£Transmit Buffer Empty InterruptΓÇ¥ All other bit combinations Reserved Note: Exception for clearing of RXINT If both SPIBUF and RXBUF (internal buffer) are full, then, reading TGINTVECT1 register (while it shows 10010) does not clear the RXINTFLG in SPIFLG register. In this case, only way to clear the Interrupt is to read out the SPIBUF again until thereΓÇÖs no more unread RX data."]
    #[inline(always)]
    pub fn intvect1(&self) -> Intvect1R {
        Intvect1R::new(((self.bits >> 1) & 0x1f) as u8)
    }
    #[doc = "Bits 6:31 - 31:6\\]
Reserved. Reads return ΓÇÿ0ΓÇÖ and writes have no effect."]
    #[inline(always)]
    pub fn nu(&self) -> NuR {
        NuR::new((self.bits >> 6) & 0x03ff_ffff)
    }
}
impl W {
    #[doc = "Bit 0 - 0:0\\]
ΓÇ£Transfer suspendedΓÇ¥ or ΓÇ£transfer finishedΓÇ¥ interrupt.(MibSPI Only) The SUSPEND1 flag is updated depending on the type of interrupt reflected by the VECTOR value field. 1 =The interrupt type is a ΓÇ£transfer suspendedΓÇ¥ interrupt. I.e. the transfer group referenced by INTVECT1 has asserted an interrupt, because the buffer to be transferred next is in ΓÇ£suspend to waitΓÇ¥ mode. 0 =The interrupt type is a ΓÇ£transfer finishedΓÇ¥ interrupt. I.e. the buffer array referenced by INTVECT1 has asserted an interrupt, because all data from the whole transfer group has been transferred. Note: Special case for SUSPEND interrupt When thereΓÇÖs a ΓÇ£transfer suspendedΓÇ¥ interrupt(SUSPEND1 bit is set to ΓÇÿ1ΓÇÖ), reading the TGINTVECT1 register does not clear the ΓÇ£TG SuspendedΓÇ¥ interrupt. The SUSPEND condition should be resolved first before the interrupt can be cleared. This condition can be cleared by writing a new data to that TXRAM location and/or reading the data from that RXRAM location depending upon the SUSPEND criteria programmed in the ΓÇ£BUFMODEΓÇ¥ field of that TXRAM location. The SUSPEND1 bit always returns value ΓÇÿ0ΓÇÖ in SPI / Compatibility mode MibSPI. Even while there is an RXOVRN or any Error interrupt in Multibuffer mode, SUSPEND1 bit stays ΓÇÿ0ΓÇÖ. Refer to Section 6.2 on page 77 &amp; Section 6.3 on page 77 for more details and notes on better handling of interrupts. Note: Reading Error Vector Reading an Error Vector in the TGINTVECT1 register will NOT clear the Error flags in the SPIFLG register. The Error Flags in SPIFLG need to be write-cleared after servicing them suitably. If ΓÇ£TG CompletedΓÇ¥ interrupt occurs for a TG and after a while ΓÇ£TG SuspendedΓÇ¥ flag too gets set for the same TG, then the TGINTVECT1 register will show ΓÇ£TG CompletedΓÇ¥ interrupt giving it higher priority than the ΓÇ£TG SuspendedΓÇ¥ interrrupt."]
    #[inline(always)]
    #[must_use]
    pub fn suspend1(&mut self) -> Suspend1W<Tgintvect1Spec> {
        Suspend1W::new(self, 0)
    }
    #[doc = "Bits 1:5 - 5:1\\]
Interrupt vector for interrupt line INT1. INTVECT1 returns the vector of the pending interrupt at interrupt line INT0. If more than one interrupt is pending, INTVECT1 always references the highest priority interrupt source first. The vectors generated are different for SPI / Compatibility mode of MibSPI and Multibuffer mode of MibSPI. INTVECT1 field just reflects the status of SPIFLG register in a vectorized format. So, any updates to SPIFLG will automatically reflect in the Vector value in this register. SPI / Compatibility mode - MibSPI The interrupts available for SPI / Compatibility mode - MibSPI, in the descending order of their priorities are as given below. Transmission Error Interrupt Receive Buffer Overrun Interrupt Receive Buffer Full Interrupt Transmit Buffer Empty Interrupt Vectors for each of these interrupts will be reflected on the INTVECT1 bits, when they occur. Reading the vectors for the ΓÇ£Receive Buffer OverrunΓÇ¥ &amp; ΓÇ£Receive Buffer FullΓÇ¥ interrupts will automatically clear the respective flags in the SPIFLG register. On reading the INTVECT1 bits, the vector of the next highest priority interrupt (if any) will then be reflected on the INTVECT1 bits. If two or more interrupts occur simultaneously, the vector for the higest priority interrupt will be reflected on the INTVECT1 bits. Reading the Vector register when ΓÇ£Transmitter EmptyΓÇ¥ is indicated does not clear the TXINTFLG in SPIFLG register. Writing a new data to SPIDATx register clears the ΓÇ£Transmitter EmptyΓÇ¥ interrupt. 00000b no interrupt pending 10001b Error interrupt pending. Refer to LS Byte of SPIFLG to determine more details about the type of error. 10011b Pending interrupt is ΓÇ£Receive Buffer Overrun InterruptΓÇ¥ 10010b Pending interrupt is ΓÇ£Receive Buiffer Full InterruptΓÇ¥ 10100b Pending interrupt is ΓÇ£Transmit Buffer Empty InterruptΓÇ¥ All other bit combinations Reserved Note: Exception for clearing of RXINT If both SPIBUF and RXBUF (internal buffer) are full, then, reading TGINTVECT1 register (while it shows 10010) does not clear the RXINTFLG in SPIFLG register. In this case, only way to clear the Interrupt is to read out the SPIBUF again until thereΓÇÖs no more unread RX data."]
    #[inline(always)]
    #[must_use]
    pub fn intvect1(&mut self) -> Intvect1W<Tgintvect1Spec> {
        Intvect1W::new(self, 1)
    }
    #[doc = "Bits 6:31 - 31:6\\]
Reserved. Reads return ΓÇÿ0ΓÇÖ and writes have no effect."]
    #[inline(always)]
    #[must_use]
    pub fn nu(&mut self) -> NuW<Tgintvect1Spec> {
        NuW::new(self, 6)
    }
}
#[doc = "SPI Interrupt Vector Register 1 / MibSPI Transfer Group Interrupt Vector Register 1\n\nYou can [`read`](crate::Reg::read) this register and get [`tgintvect1::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`tgintvect1::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct Tgintvect1Spec;
impl crate::RegisterSpec for Tgintvect1Spec {
    type Ux = u32;
}
#[doc = "`read()` method returns [`tgintvect1::R`](R) reader structure"]
impl crate::Readable for Tgintvect1Spec {}
#[doc = "`write(|w| ..)` method takes [`tgintvect1::W`](W) writer structure"]
impl crate::Writable for Tgintvect1Spec {
    type Safety = crate::Unsafe;
    const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
    const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
}
#[doc = "`reset()` method sets TGINTVECT1 to value 0"]
impl crate::Resettable for Tgintvect1Spec {
    const RESET_VALUE: u32 = 0;
}
