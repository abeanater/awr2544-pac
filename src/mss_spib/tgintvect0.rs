#[doc = "Register `TGINTVECT0` reader"]
pub type R = crate::R<Tgintvect0Spec>;
#[doc = "Register `TGINTVECT0` writer"]
pub type W = crate::W<Tgintvect0Spec>;
#[doc = "Field `SUSPEND0` reader - 0:0\\]
ΓÇ£Transfer suspendedΓÇ¥ or ΓÇ£transfer finishedΓÇ¥ interrupt.(MibSPI only) The SUSPEND0 flag is updated depending on the type of interrupt reflected by the VECTOR value field. 1 =The interrupt type is a ΓÇ£transfer suspendedΓÇ¥ interrupt. I.e. the transfer group referenced by INTVECT0 has asserted an interrupt, because the buffer to be transferred next is in ΓÇ£suspend to waitΓÇ¥ mode. 0 =The interrupt type is a ΓÇ£transfer finishedΓÇ¥ interrupt. I.e. the buffer array referenced by INTVECT0 has asserted an interrupt, because all of the data from the whole transfer group has been transferred. Note: Special case for SUSPEND interrupt When thereΓÇÖs a ΓÇ£transfer suspendedΓÇ¥ interrupt (SUSPEND0 bit is set to ΓÇÿ1ΓÇÖ), reading the TGINTVECT0 register does not clear the ΓÇ£TG SuspendedΓÇ¥ interrupt. The SUSPEND condition should be resolved first before the interrupt can be cleared. The SUSPEND condition can be cleared by writing a new data to that TXRAM location and/or reading the data from that RXRAM location depending upon the SUSPEND criteria programmed in the ΓÇ£BUFMODEΓÇ¥ field of that TXRAM location. The SUSPEND0 bit always returns value ΓÇÿ0ΓÇÖ in SPI / Compatibility mode MibSPI. When there is an RXOVRN or any Error interrupt in Multibuffer mode, SUSPEND0 bit stays ΓÇÿ0ΓÇÖ. Refer to Section 6.2 on page 77 &amp; Section 6.3 on page 77 for more details and notes on better handling of interrupts. Note: Reading Error Vector Reading an Error Vector in the TGINTVECT0 register will NOT clear the Error flags in the SPIFLG register. The Error Flags in SPIFLG need to be write-cleared after servicing them suitably. If ΓÇ£TG CompletedΓÇ¥ interrupt occurs for a TG and after a while ΓÇ£TG SuspendedΓÇ¥ flag too gets set for the same TG, then the TGINTVECT0 register will show ΓÇ£TG CompletedΓÇ¥ interrupt giving it higher priority than the ΓÇ£TG SuspendedΓÇ¥ interrrupt."]
pub type Suspend0R = crate::BitReader;
#[doc = "Field `SUSPEND0` writer - 0:0\\]
ΓÇ£Transfer suspendedΓÇ¥ or ΓÇ£transfer finishedΓÇ¥ interrupt.(MibSPI only) The SUSPEND0 flag is updated depending on the type of interrupt reflected by the VECTOR value field. 1 =The interrupt type is a ΓÇ£transfer suspendedΓÇ¥ interrupt. I.e. the transfer group referenced by INTVECT0 has asserted an interrupt, because the buffer to be transferred next is in ΓÇ£suspend to waitΓÇ¥ mode. 0 =The interrupt type is a ΓÇ£transfer finishedΓÇ¥ interrupt. I.e. the buffer array referenced by INTVECT0 has asserted an interrupt, because all of the data from the whole transfer group has been transferred. Note: Special case for SUSPEND interrupt When thereΓÇÖs a ΓÇ£transfer suspendedΓÇ¥ interrupt (SUSPEND0 bit is set to ΓÇÿ1ΓÇÖ), reading the TGINTVECT0 register does not clear the ΓÇ£TG SuspendedΓÇ¥ interrupt. The SUSPEND condition should be resolved first before the interrupt can be cleared. The SUSPEND condition can be cleared by writing a new data to that TXRAM location and/or reading the data from that RXRAM location depending upon the SUSPEND criteria programmed in the ΓÇ£BUFMODEΓÇ¥ field of that TXRAM location. The SUSPEND0 bit always returns value ΓÇÿ0ΓÇÖ in SPI / Compatibility mode MibSPI. When there is an RXOVRN or any Error interrupt in Multibuffer mode, SUSPEND0 bit stays ΓÇÿ0ΓÇÖ. Refer to Section 6.2 on page 77 &amp; Section 6.3 on page 77 for more details and notes on better handling of interrupts. Note: Reading Error Vector Reading an Error Vector in the TGINTVECT0 register will NOT clear the Error flags in the SPIFLG register. The Error Flags in SPIFLG need to be write-cleared after servicing them suitably. If ΓÇ£TG CompletedΓÇ¥ interrupt occurs for a TG and after a while ΓÇ£TG SuspendedΓÇ¥ flag too gets set for the same TG, then the TGINTVECT0 register will show ΓÇ£TG CompletedΓÇ¥ interrupt giving it higher priority than the ΓÇ£TG SuspendedΓÇ¥ interrrupt."]
pub type Suspend0W<'a, REG> = crate::BitWriter<'a, REG>;
#[doc = "Field `INTVECT0` reader - 5:1\\]
Interrupt vector for interrupt line INT0. INTVECT0 returns the vector of the pending interrupt at interrupt line INT0. If more than one interrupts are pending, INTVECT0 always references the highest priority interrupt source first. The vectors generated are different for SPI / Compatibility mode of MibSPI and Multibuffer mode of MibSPI. INTVECT0 field just reflects the status of SPIFLG register in a vectorized format. So, any updates to SPIFLG will automatically reflect in the Vector value in this register. SPI / Compatibility mode - MibSPI The interrupts available for SPI or Compatibility mode - MibSPI, in the descending order of their priorities are as given below. Transmission Error Interrupt Receive Buffer Overrun Interrupt Receive Buffer Full Interrupt Transmit Buffer Empty Interrupt Vectors for each of these interrupts will be reflected on the INTVECT0 bits, when they occur. Reading the vectors for the ΓÇ£Receive Buffer OverrunΓÇ¥ &amp; ΓÇ£Receive Buffer FullΓÇ¥ interrupts will automatically clear the respective flags in the SPIFLG register. On reading the INTVECT0 bits, the vector of the next highest priority interrupt (if any) will be then reflected on the INTVECT0 bits. If two or more interrupts occur simultaneously, the vector for the higest priority interrupt will be reflected on the INTVECT0 bits. Reading the Vector register when ΓÇ£Transmitter EmptyΓÇ¥ is indicated does not clear the TXINTFLG in SPIFLG register. Writing a new data to SPIDATx register clears the ΓÇ£Transmitter EmptyΓÇ¥ interrupt. INTVECT0\\[4:0\\]
Description 00000b no interrupt pending 10001b Error interrupt pending. Refer to Least Significant (LS) Byte of SPIFLG to determine more details about the type of error. 10011b Pending interrupt is ΓÇ£Receive Buffer Overrun InterruptΓÇ¥ 10010b Pending interrupt is ΓÇ£Receive Buffer Full InterruptΓÇ¥ 10100b Pending interrupt is ΓÇ£Transmit Buffer Empty InterruptΓÇ¥ All other bit combinations Reserved Note: Exception for clearing of RXINT If both SPIBUF and RXBUF (internal buffer) are full, then, reading TGINTVECT0 register (while it shows 10010) does not clear the RXINTFLG in SPIFLG register. In this case, only way to clear the Interrupt is to read the SPIBUF again until thereΓÇÖs no more unread RX data."]
pub type Intvect0R = crate::FieldReader;
#[doc = "Field `INTVECT0` writer - 5:1\\]
Interrupt vector for interrupt line INT0. INTVECT0 returns the vector of the pending interrupt at interrupt line INT0. If more than one interrupts are pending, INTVECT0 always references the highest priority interrupt source first. The vectors generated are different for SPI / Compatibility mode of MibSPI and Multibuffer mode of MibSPI. INTVECT0 field just reflects the status of SPIFLG register in a vectorized format. So, any updates to SPIFLG will automatically reflect in the Vector value in this register. SPI / Compatibility mode - MibSPI The interrupts available for SPI or Compatibility mode - MibSPI, in the descending order of their priorities are as given below. Transmission Error Interrupt Receive Buffer Overrun Interrupt Receive Buffer Full Interrupt Transmit Buffer Empty Interrupt Vectors for each of these interrupts will be reflected on the INTVECT0 bits, when they occur. Reading the vectors for the ΓÇ£Receive Buffer OverrunΓÇ¥ &amp; ΓÇ£Receive Buffer FullΓÇ¥ interrupts will automatically clear the respective flags in the SPIFLG register. On reading the INTVECT0 bits, the vector of the next highest priority interrupt (if any) will be then reflected on the INTVECT0 bits. If two or more interrupts occur simultaneously, the vector for the higest priority interrupt will be reflected on the INTVECT0 bits. Reading the Vector register when ΓÇ£Transmitter EmptyΓÇ¥ is indicated does not clear the TXINTFLG in SPIFLG register. Writing a new data to SPIDATx register clears the ΓÇ£Transmitter EmptyΓÇ¥ interrupt. INTVECT0\\[4:0\\]
Description 00000b no interrupt pending 10001b Error interrupt pending. Refer to Least Significant (LS) Byte of SPIFLG to determine more details about the type of error. 10011b Pending interrupt is ΓÇ£Receive Buffer Overrun InterruptΓÇ¥ 10010b Pending interrupt is ΓÇ£Receive Buffer Full InterruptΓÇ¥ 10100b Pending interrupt is ΓÇ£Transmit Buffer Empty InterruptΓÇ¥ All other bit combinations Reserved Note: Exception for clearing of RXINT If both SPIBUF and RXBUF (internal buffer) are full, then, reading TGINTVECT0 register (while it shows 10010) does not clear the RXINTFLG in SPIFLG register. In this case, only way to clear the Interrupt is to read the SPIBUF again until thereΓÇÖs no more unread RX data."]
pub type Intvect0W<'a, REG> = crate::FieldWriter<'a, REG, 5>;
#[doc = "Field `NU` reader - 31:6\\]
Reserved. Reads return ΓÇÿ0ΓÇÖ and writes have no effect."]
pub type NuR = crate::FieldReader<u32>;
#[doc = "Field `NU` writer - 31:6\\]
Reserved. Reads return ΓÇÿ0ΓÇÖ and writes have no effect."]
pub type NuW<'a, REG> = crate::FieldWriter<'a, REG, 26, u32>;
impl R {
    #[doc = "Bit 0 - 0:0\\]
ΓÇ£Transfer suspendedΓÇ¥ or ΓÇ£transfer finishedΓÇ¥ interrupt.(MibSPI only) The SUSPEND0 flag is updated depending on the type of interrupt reflected by the VECTOR value field. 1 =The interrupt type is a ΓÇ£transfer suspendedΓÇ¥ interrupt. I.e. the transfer group referenced by INTVECT0 has asserted an interrupt, because the buffer to be transferred next is in ΓÇ£suspend to waitΓÇ¥ mode. 0 =The interrupt type is a ΓÇ£transfer finishedΓÇ¥ interrupt. I.e. the buffer array referenced by INTVECT0 has asserted an interrupt, because all of the data from the whole transfer group has been transferred. Note: Special case for SUSPEND interrupt When thereΓÇÖs a ΓÇ£transfer suspendedΓÇ¥ interrupt (SUSPEND0 bit is set to ΓÇÿ1ΓÇÖ), reading the TGINTVECT0 register does not clear the ΓÇ£TG SuspendedΓÇ¥ interrupt. The SUSPEND condition should be resolved first before the interrupt can be cleared. The SUSPEND condition can be cleared by writing a new data to that TXRAM location and/or reading the data from that RXRAM location depending upon the SUSPEND criteria programmed in the ΓÇ£BUFMODEΓÇ¥ field of that TXRAM location. The SUSPEND0 bit always returns value ΓÇÿ0ΓÇÖ in SPI / Compatibility mode MibSPI. When there is an RXOVRN or any Error interrupt in Multibuffer mode, SUSPEND0 bit stays ΓÇÿ0ΓÇÖ. Refer to Section 6.2 on page 77 &amp; Section 6.3 on page 77 for more details and notes on better handling of interrupts. Note: Reading Error Vector Reading an Error Vector in the TGINTVECT0 register will NOT clear the Error flags in the SPIFLG register. The Error Flags in SPIFLG need to be write-cleared after servicing them suitably. If ΓÇ£TG CompletedΓÇ¥ interrupt occurs for a TG and after a while ΓÇ£TG SuspendedΓÇ¥ flag too gets set for the same TG, then the TGINTVECT0 register will show ΓÇ£TG CompletedΓÇ¥ interrupt giving it higher priority than the ΓÇ£TG SuspendedΓÇ¥ interrrupt."]
    #[inline(always)]
    pub fn suspend0(&self) -> Suspend0R {
        Suspend0R::new((self.bits & 1) != 0)
    }
    #[doc = "Bits 1:5 - 5:1\\]
Interrupt vector for interrupt line INT0. INTVECT0 returns the vector of the pending interrupt at interrupt line INT0. If more than one interrupts are pending, INTVECT0 always references the highest priority interrupt source first. The vectors generated are different for SPI / Compatibility mode of MibSPI and Multibuffer mode of MibSPI. INTVECT0 field just reflects the status of SPIFLG register in a vectorized format. So, any updates to SPIFLG will automatically reflect in the Vector value in this register. SPI / Compatibility mode - MibSPI The interrupts available for SPI or Compatibility mode - MibSPI, in the descending order of their priorities are as given below. Transmission Error Interrupt Receive Buffer Overrun Interrupt Receive Buffer Full Interrupt Transmit Buffer Empty Interrupt Vectors for each of these interrupts will be reflected on the INTVECT0 bits, when they occur. Reading the vectors for the ΓÇ£Receive Buffer OverrunΓÇ¥ &amp; ΓÇ£Receive Buffer FullΓÇ¥ interrupts will automatically clear the respective flags in the SPIFLG register. On reading the INTVECT0 bits, the vector of the next highest priority interrupt (if any) will be then reflected on the INTVECT0 bits. If two or more interrupts occur simultaneously, the vector for the higest priority interrupt will be reflected on the INTVECT0 bits. Reading the Vector register when ΓÇ£Transmitter EmptyΓÇ¥ is indicated does not clear the TXINTFLG in SPIFLG register. Writing a new data to SPIDATx register clears the ΓÇ£Transmitter EmptyΓÇ¥ interrupt. INTVECT0\\[4:0\\]
Description 00000b no interrupt pending 10001b Error interrupt pending. Refer to Least Significant (LS) Byte of SPIFLG to determine more details about the type of error. 10011b Pending interrupt is ΓÇ£Receive Buffer Overrun InterruptΓÇ¥ 10010b Pending interrupt is ΓÇ£Receive Buffer Full InterruptΓÇ¥ 10100b Pending interrupt is ΓÇ£Transmit Buffer Empty InterruptΓÇ¥ All other bit combinations Reserved Note: Exception for clearing of RXINT If both SPIBUF and RXBUF (internal buffer) are full, then, reading TGINTVECT0 register (while it shows 10010) does not clear the RXINTFLG in SPIFLG register. In this case, only way to clear the Interrupt is to read the SPIBUF again until thereΓÇÖs no more unread RX data."]
    #[inline(always)]
    pub fn intvect0(&self) -> Intvect0R {
        Intvect0R::new(((self.bits >> 1) & 0x1f) as u8)
    }
    #[doc = "Bits 6:31 - 31:6\\]
Reserved. Reads return ΓÇÿ0ΓÇÖ and writes have no effect."]
    #[inline(always)]
    pub fn nu(&self) -> NuR {
        NuR::new((self.bits >> 6) & 0x03ff_ffff)
    }
}
impl W {
    #[doc = "Bit 0 - 0:0\\]
ΓÇ£Transfer suspendedΓÇ¥ or ΓÇ£transfer finishedΓÇ¥ interrupt.(MibSPI only) The SUSPEND0 flag is updated depending on the type of interrupt reflected by the VECTOR value field. 1 =The interrupt type is a ΓÇ£transfer suspendedΓÇ¥ interrupt. I.e. the transfer group referenced by INTVECT0 has asserted an interrupt, because the buffer to be transferred next is in ΓÇ£suspend to waitΓÇ¥ mode. 0 =The interrupt type is a ΓÇ£transfer finishedΓÇ¥ interrupt. I.e. the buffer array referenced by INTVECT0 has asserted an interrupt, because all of the data from the whole transfer group has been transferred. Note: Special case for SUSPEND interrupt When thereΓÇÖs a ΓÇ£transfer suspendedΓÇ¥ interrupt (SUSPEND0 bit is set to ΓÇÿ1ΓÇÖ), reading the TGINTVECT0 register does not clear the ΓÇ£TG SuspendedΓÇ¥ interrupt. The SUSPEND condition should be resolved first before the interrupt can be cleared. The SUSPEND condition can be cleared by writing a new data to that TXRAM location and/or reading the data from that RXRAM location depending upon the SUSPEND criteria programmed in the ΓÇ£BUFMODEΓÇ¥ field of that TXRAM location. The SUSPEND0 bit always returns value ΓÇÿ0ΓÇÖ in SPI / Compatibility mode MibSPI. When there is an RXOVRN or any Error interrupt in Multibuffer mode, SUSPEND0 bit stays ΓÇÿ0ΓÇÖ. Refer to Section 6.2 on page 77 &amp; Section 6.3 on page 77 for more details and notes on better handling of interrupts. Note: Reading Error Vector Reading an Error Vector in the TGINTVECT0 register will NOT clear the Error flags in the SPIFLG register. The Error Flags in SPIFLG need to be write-cleared after servicing them suitably. If ΓÇ£TG CompletedΓÇ¥ interrupt occurs for a TG and after a while ΓÇ£TG SuspendedΓÇ¥ flag too gets set for the same TG, then the TGINTVECT0 register will show ΓÇ£TG CompletedΓÇ¥ interrupt giving it higher priority than the ΓÇ£TG SuspendedΓÇ¥ interrrupt."]
    #[inline(always)]
    #[must_use]
    pub fn suspend0(&mut self) -> Suspend0W<Tgintvect0Spec> {
        Suspend0W::new(self, 0)
    }
    #[doc = "Bits 1:5 - 5:1\\]
Interrupt vector for interrupt line INT0. INTVECT0 returns the vector of the pending interrupt at interrupt line INT0. If more than one interrupts are pending, INTVECT0 always references the highest priority interrupt source first. The vectors generated are different for SPI / Compatibility mode of MibSPI and Multibuffer mode of MibSPI. INTVECT0 field just reflects the status of SPIFLG register in a vectorized format. So, any updates to SPIFLG will automatically reflect in the Vector value in this register. SPI / Compatibility mode - MibSPI The interrupts available for SPI or Compatibility mode - MibSPI, in the descending order of their priorities are as given below. Transmission Error Interrupt Receive Buffer Overrun Interrupt Receive Buffer Full Interrupt Transmit Buffer Empty Interrupt Vectors for each of these interrupts will be reflected on the INTVECT0 bits, when they occur. Reading the vectors for the ΓÇ£Receive Buffer OverrunΓÇ¥ &amp; ΓÇ£Receive Buffer FullΓÇ¥ interrupts will automatically clear the respective flags in the SPIFLG register. On reading the INTVECT0 bits, the vector of the next highest priority interrupt (if any) will be then reflected on the INTVECT0 bits. If two or more interrupts occur simultaneously, the vector for the higest priority interrupt will be reflected on the INTVECT0 bits. Reading the Vector register when ΓÇ£Transmitter EmptyΓÇ¥ is indicated does not clear the TXINTFLG in SPIFLG register. Writing a new data to SPIDATx register clears the ΓÇ£Transmitter EmptyΓÇ¥ interrupt. INTVECT0\\[4:0\\]
Description 00000b no interrupt pending 10001b Error interrupt pending. Refer to Least Significant (LS) Byte of SPIFLG to determine more details about the type of error. 10011b Pending interrupt is ΓÇ£Receive Buffer Overrun InterruptΓÇ¥ 10010b Pending interrupt is ΓÇ£Receive Buffer Full InterruptΓÇ¥ 10100b Pending interrupt is ΓÇ£Transmit Buffer Empty InterruptΓÇ¥ All other bit combinations Reserved Note: Exception for clearing of RXINT If both SPIBUF and RXBUF (internal buffer) are full, then, reading TGINTVECT0 register (while it shows 10010) does not clear the RXINTFLG in SPIFLG register. In this case, only way to clear the Interrupt is to read the SPIBUF again until thereΓÇÖs no more unread RX data."]
    #[inline(always)]
    #[must_use]
    pub fn intvect0(&mut self) -> Intvect0W<Tgintvect0Spec> {
        Intvect0W::new(self, 1)
    }
    #[doc = "Bits 6:31 - 31:6\\]
Reserved. Reads return ΓÇÿ0ΓÇÖ and writes have no effect."]
    #[inline(always)]
    #[must_use]
    pub fn nu(&mut self) -> NuW<Tgintvect0Spec> {
        NuW::new(self, 6)
    }
}
#[doc = "SPI Interrupt Vector Register 0 / MibSPI Transfer Group Interrupt Vector Register 0\n\nYou can [`read`](crate::Reg::read) this register and get [`tgintvect0::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`tgintvect0::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct Tgintvect0Spec;
impl crate::RegisterSpec for Tgintvect0Spec {
    type Ux = u32;
}
#[doc = "`read()` method returns [`tgintvect0::R`](R) reader structure"]
impl crate::Readable for Tgintvect0Spec {}
#[doc = "`write(|w| ..)` method takes [`tgintvect0::W`](W) writer structure"]
impl crate::Writable for Tgintvect0Spec {
    type Safety = crate::Unsafe;
    const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
    const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
}
#[doc = "`reset()` method sets TGINTVECT0 to value 0"]
impl crate::Resettable for Tgintvect0Spec {
    const RESET_VALUE: u32 = 0;
}
